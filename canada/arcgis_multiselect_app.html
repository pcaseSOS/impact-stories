<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Canada Towns Interactive Map</title>

    <link rel="stylesheet" href="https://js.arcgis.com/4.28/esri/themes/light/main.css">
    <script src="https://js.arcgis.com/4.28/"></script>

    <style>
        html, body, #viewDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
            font-family: Arial, sans-serif;
        }

        .toolbar {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toolbar button {
            background: #0079c1;
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            min-width: 180px;
            text-align: left;
        }

        .toolbar button:hover {
            background: #005a87;
        }

        .toolbar button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .toolbar button.active {
            background: #28a745;
        }

        .toolbar button.danger {
            background: #dc3545;
        }

        .toolbar button.danger:hover {
            background: #c82333;
        }

        .selection-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            width: 300px;
            max-height: 400px;
            display: flex;
            flex-direction: column;
            z-index: 100;
            overflow: hidden;
        }
        
        .panel-header {
            background: #f5f5f5;
            padding: 10px 15px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
        }
        
        .selection-list {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }
        
        .selection-layer-header {
            padding: 8px 15px;
            background-color: #f8f9fa;
            font-size: 12px;
            font-weight: bold;
            color: #6c757d;
            border-bottom: 1px solid #e9ecef;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        
        .selection-item {
            padding: 8px 15px 8px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .selection-item:hover {
            background-color: #f8f9fa;
        }
        
        .selection-name {
            flex: 1;
            margin-right: 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .remove-btn {
            background: none;
            border: none;
            color: #adb5bd;
            font-size: 18px;
            cursor: pointer;
            padding: 0 5px;
            line-height: 1;
            border-radius: 3px;
            transition: all 0.2s;
        }
        
        .remove-btn:hover {
            color: #dc3545;
            background-color: rgba(220, 53, 69, 0.1);
        }
        
        .empty-selection {
            padding: 20px 15px;
            color: #6c757d;
            text-align: center;
            font-style: italic;
            font-size: 14px;
        }
        
        /* Status message styling */
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 1000;
            max-width: 300px;
            pointer-events: none;
        }

        .tooltip {
            position: fixed;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 200px;
            word-wrap: break-word;
        }
        
        /* Search bar styles */
        .search-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            width: 300px;
            display: flex;
            flex-direction: column;
        }
        
        .search-input-container {
            display: flex;
            width: 100%;
        }
        
        .search-input {
            flex-grow: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 4px 0 0 4px;
            font-size: 14px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .search-button {
            background: #0079c1;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 0 4px 4px 0;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .search-button:hover {
            background: #005a87;
        }
        
        .search-results {
            background: white;
            border-radius: 0 0 4px 4px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            display: none;
            position: absolute;
            width: 100%;
            z-index: 1000;
        }
        
        .search-layer-header {
            padding: 8px 12px;
            background-color: #f5f5f5;
            font-weight: bold;
            font-size: 12px;
            color: #555;
            border-bottom: 1px solid #e0e0e0;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        
        .search-item-name {
            font-weight: 500;
            margin-bottom: 2px;
        }
        
        .search-item-layer {
            font-size: 11px;
            color: #666;
            opacity: 0.8;
        }
        
        .search-result-item {
            padding: 10px 15px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .search-result-item:hover {
            background-color: #f0f7ff;
        }
        
        .search-result-item:active {
            background-color: #e0f0ff;
        }
        
        .search-result-item:last-child {
            border-bottom: none;
        }
    </style>
</head>

<body>
    <div id="viewDiv"></div>
    
    <!-- Search Bar -->
    <div class="search-container">
        <div class="search-input-container">
            <input type="text" class="search-input" id="searchInput" placeholder="Search for a town...">
            <button class="search-button" id="searchButton">üîç</button>
        </div>
        <div class="search-results" id="searchResults">
            <!-- Search results will appear here -->
        </div>
    </div>

    <!-- Toolbar -->
    <div class="toolbar">
        <button id="selectModeBtn">üñ±Ô∏è Single Select Mode</button>
        <button id="downloadBtn" disabled>üì• Download Selected (0)</button>
        <button id="clearAllBtn" disabled class="danger">üóëÔ∏è Clear All Selections</button>
    </div>

    <!-- Selection Panel -->
    <div id="selectionPanel">
        <div class="panel-header">
            <span>Selected Towns (<span id="selectionCount">0</span>)</span>
            <button id="panelToggle" style="background: none; border: none; color: white; cursor: pointer;">‚àí</button>
        </div>
        <div class="panel-content" id="selectionList">
            <!-- Selected items will be populated here -->
        </div>
        <div class="panel-footer">
            Multiple selection: Hold Ctrl/Cmd + click or Multi-Select Mode
        </div>
    </div>

    <div id="status">Single-click to select towns. For multiple: Hold Cmd/Ctrl or Multi-Select Mode.</div>

    <script>
        require([
            "esri/Map",
            "esri/views/MapView",
            "esri/layers/FeatureLayer",
            "esri/symbols/SimpleFillSymbol",
            "esri/symbols/SimpleLineSymbol",
            "esri/renderers/SimpleRenderer",
            "esri/Graphic",
            "esri/geometry/geometryEngine",
            "esri/widgets/Sketch",
            "esri/layers/GraphicsLayer",
            "esri/geometry/projection",
            "esri/geometry/SpatialReference"
        ], function(Map, MapView, FeatureLayer, SimpleFillSymbol, SimpleLineSymbol, SimpleRenderer, Graphic, geometryEngine, Sketch, GraphicsLayer, projection, SpatialReference) {

            let selectedFeatures = []; // Array to store multiple selected features
            let highlightSelections = []; // Array to store highlight handles
            let multiSelectMode = false;

            // UI Elements
            const downloadBtn = document.getElementById('downloadBtn');
            const clearAllBtn = document.getElementById('clearAllBtn');
            const selectModeBtn = document.getElementById('selectModeBtn');
            const selectionPanel = document.getElementById('selectionPanel');
            const selectionList = document.getElementById('selectionList');
            const selectionCount = document.getElementById('selectionCount');
            const panelToggle = document.getElementById('panelToggle');
            const status = document.getElementById('status');

            // Create the map
            const map = new Map({
                basemap: "streets-navigation-vector"
            });

            // Create the map view
            const view = new MapView({
                container: "viewDiv",
                map: map,
                center: [-106.3468, 56.1304], // Center of Canada
                zoom: 4
            });

            // Define renderer for the layer
            const renderer = new SimpleRenderer({
                symbol: new SimpleFillSymbol({
                    color: [51, 51, 204, 0.3],
                    outline: new SimpleLineSymbol({
                        color: [51, 51, 204, 0.8],
                        width: 1
                    })
                })
            });

            // Create the Canada Towns layer
            const canadaTownsLayer = new FeatureLayer({
                url: "https://services3.arcgis.com/8lRAGVDTn4JslcF7/arcgis/rest/services/Canada_Town/FeatureServer",
                renderer: new SimpleRenderer({
                    symbol: new SimpleFillSymbol({
                        color: [51, 51, 204, 0.3],
                        outline: new SimpleLineSymbol({
                            color: [51, 51, 204, 0.8],
                            width: 1
                        })
                    })
                }),
                outFields: ["*"],
                title: "Canada Towns"
            });

            // Create the PSAP layer
            const psapLayer = new FeatureLayer({
                url: "https://services2.arcgis.com/8fY1lwl7Wf0qomfH/arcgis/rest/services/PSAP_Boundaries/FeatureServer/0",
                renderer: new SimpleRenderer({
                    symbol: new SimpleFillSymbol({
                        color: [204, 51, 51, 0.3],
                        outline: new SimpleLineSymbol({
                            color: [204, 51, 51, 0.8],
                            width: 1
                        })
                    })
                }),
                outFields: ["*"],
                title: "PSAP Boundaries"
            });

            // Add the layers to the map
            map.addMany([psapLayer, canadaTownsLayer]);

            // Create tooltip element
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.style.display = 'none';
            document.body.appendChild(tooltip);



            // Helper function to get consistent feature ID
            function getFeatureId(feature) {
                return feature.attributes.OBJECTID ||
                       feature.attributes.FID ||
                       feature.attributes.ObjectId ||
                       JSON.stringify(feature.attributes);
            }

            // Helper function to get town name from attributes
            function getTownName(attributes) {
                let townName = attributes.NAME || attributes.name || attributes.TOWN_NAME || 'Unknown Town';

                Object.keys(attributes).forEach(key => {
                    if ((key.toLowerCase().includes('name') ||
                         key.toLowerCase().includes('town') ||
                         key.toLowerCase().includes('city')) &&
                         attributes[key] && townName === 'Unknown Town') {
                        townName = attributes[key];
                    }
                });

                return townName;
            }

            // Helper function to get feature name
            function getFeatureName(feature) {
                return getTownName(feature.attributes);
            }

            // Helper function to get layer name for a feature
            function getLayerName(layer) {
                if (layer === canadaTownsLayer) return 'Canada Town';
                if (layer === psapLayer) return 'PSAP';
                return 'Unknown Layer';
            }

            // Helper function to update selection panel
            function updateSelectionPanel() {
                selectionList.innerHTML = '';

                if (selectedFeatures.length === 0) {
                    selectionList.innerHTML = '<div class="empty-selection">No features selected</div>';
                    selectionCount.textContent = '0 selected';
                    return;
                }

                selectionCount.textContent = `${selectedFeatures.length} selected`;

                // Sort selections by layer and then by name
                selectedFeatures.sort((a, b) => {
                    // First sort by layer
                    const layerCompare = getLayerName(a.layer).localeCompare(getLayerName(b.layer));
                    if (layerCompare !== 0) return layerCompare;

                    // Then sort by name within the same layer
                    const nameA = getFeatureName(a).toUpperCase();
                    const nameB = getFeatureName(b).toUpperCase();
                    return nameA.localeCompare(nameB);
                });

                let currentLayer = null;

                // Add each selected feature to the panel
                selectedFeatures.forEach((feature, index) => {
                    // Add layer header if this is a new layer
                    if (currentLayer !== feature.layer) {
                        currentLayer = feature.layer;
                        const layerHeader = document.createElement('div');
                        layerHeader.className = 'selection-layer-header';
                        layerHeader.textContent = getLayerName(feature.layer);
                        selectionList.appendChild(layerHeader);
                    }

                    const item = document.createElement('div');
                    item.className = 'selection-item';

                    const name = document.createElement('span');
                    name.className = 'selection-name';
                    name.textContent = getFeatureName(feature);

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-btn';
                    removeBtn.textContent = '√ó';
                    removeBtn.title = 'Remove from selection';
                    removeBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        removeFromSelection(index);
                    });

                    item.appendChild(name);
                    item.appendChild(removeBtn);

                    // Add click to zoom to feature
                    item.addEventListener('click', () => {
                        view.goTo({
                            target: feature.geometry,
                            zoom: 12
                        });
                    });

                    selectionList.appendChild(item);
                });
            }

            // Helper function to remove item from selection
            function removeFromSelection(index) {
                if (index >= 0 && index < selectedFeatures.length) {
                    const featureToRemove = selectedFeatures[index];
                    
                    // Find and remove the highlight for this feature
                    const highlightIndex = highlightSelections.findIndex(h => 
                        h && 
                        h.feature.attributes.OBJECTID === featureToRemove.attributes.OBJECTID &&
                        h.layer === featureToRemove.layer
                    );
                    
                    if (highlightIndex !== -1) {
                        highlightSelections[highlightIndex].remove();
                        highlightSelections.splice(highlightIndex, 1);
                    }

                    // Remove from selected features
                    selectedFeatures.splice(index, 1);

                    updateSelectionPanel();
                    updateStatus();
                }
            }

            // Helper function to clear all selections
            function clearAllSelections() {
                // Remove all highlights
                highlightSelections.forEach(highlight => {
                    if (highlight && typeof highlight.remove === 'function') {
                        highlight.remove();
                    } else if (highlight && highlight.remove && typeof highlight.remove.remove === 'function') {
                        // Handle case where highlight is an object with a remove method
                        highlight.remove.remove();
                    }
                });

                selectedFeatures = [];
                highlightSelections = [];
                updateSelectionPanel();
                updateStatus();
                status.textContent = 'All selections cleared';
            }

            // Helper function to update status message
            function updateStatus() {
                if (selectedFeatures.length === 0) {
                    if (multiSelectMode) {
                        status.textContent = 'üîÑ Multi-select mode active: Click towns to add/remove from selection';
                    } else {
                        // Detect if user is on Mac for better instructions
                        const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                        const modifierKey = isMac ? 'Cmd' : 'Ctrl';
                        status.textContent = `Single-click to select towns. Hold ${modifierKey} or use Multi-Select Mode for multiple selections.`;
                    }
                } else {
                    let modeText = '';
                    if (multiSelectMode) modeText = ' (Multi-select mode)';

                    status.textContent = `${selectedFeatures.length} town${selectedFeatures.length > 1 ? 's' : ''} selected${modeText}`;
                }
            }

            // Handle mouse move for hover effect
            view.on("pointer-move", function(event) {
                view.hitTest(event).then(function(response) {
                    // Find the first graphic from either layer
                    const result = response.results.find(r => 
                        r.graphic && (r.graphic.layer === canadaTownsLayer || r.graphic.layer === psapLayer)
                    );

                    if (result) {
                        const graphic = result.graphic;
                        const featureName = getFeatureName(graphic);

                        tooltip.innerHTML = `<strong>${featureName}</strong>`;
                        tooltip.style.display = 'block';
                        tooltip.style.left = event.x + 15 + 'px';
                        tooltip.style.top = event.y - 15 + 'px';

                        view.container.style.cursor = "pointer";
                    } else {
                        tooltip.style.display = 'none';
                        view.container.style.cursor = "default";
                    }
                });
            });

            // Handle mouse leave
            view.on("pointer-leave", function() {
                tooltip.style.display = 'none';
                view.container.style.cursor = "default";
            });

            // Function to handle feature selection
            function handleFeatureSelection(graphic, layer) {
                // Check if already selected
                const isSelected = selectedFeatures.some(f => 
                    f.attributes.OBJECTID === graphic.attributes.OBJECTID && 
                    f.layer === layer
                );
                
                if (isSelected) {
                    // If in multi-select mode and feature is already selected, remove it
                    if (multiSelectMode || event.native.ctrlKey || event.native.metaKey) {
                        selectedFeatures = selectedFeatures.filter(f => 
                            !(f.attributes.OBJECTID === graphic.attributes.OBJECTID && f.layer === layer)
                        );
                        
                        // Remove highlight
                        const highlightIndex = highlightSelections.findIndex(h => 
                            h.feature.attributes.OBJECTID === graphic.attributes.OBJECTID &&
                            h.layer === layer
                        );
                        if (highlightIndex > -1) {
                            highlightSelections[highlightIndex].remove();
                            highlightSelections.splice(highlightIndex, 1);
                        }
                        
                        status.textContent = `Removed ${getFeatureName(graphic)} from selection (${selectedFeatures.length} total)`;
                    }
                } else {
                    // If not in multi-select mode, clear previous selections
                    if (!multiSelectMode && !event.native.ctrlKey && !event.native.metaKey) {
                        clearAllSelections();
                    }
                    
                    // Add to selection
                    selectedFeatures.push(graphic);
                    
                    // Highlight selected feature
                    view.whenLayerView(layer).then(function(layerView) {
                        const highlight = {
                            remove: layerView.highlight(graphic),
                            feature: graphic,
                            layer: layer
                        };
                        highlightSelections.push(highlight);
                    });

                    updateSelectionPanel();
                    status.textContent = `Added ${getFeatureName(graphic)} to selection (${selectedFeatures.length} total)`;
                }

                updateSelectionPanel();
                updateStatus();
            }
            
            // Handle click for selection
            view.on("click", function(event) {
                view.hitTest(event).then(function(response) {
                    // Check if we clicked on a graphic
                    if (response.results.length > 0) {
                        const graphic = response.results[0].graphic;
                        
                        // Check which layer was clicked
                        if (graphic.layer === canadaTownsLayer || graphic.layer === psapLayer) {
                            handleFeatureSelection(graphic, graphic.layer);
                        } else {
                            // Clicked on something else (like basemap)
                            if (!multiSelectMode && !event.native.ctrlKey && !event.native.metaKey) {
                                clearAllSelections();
                            }
                        }
                    } else {
                        // Clicked on empty area
                        if (!multiSelectMode && !event.native.ctrlKey && !event.native.metaKey) {
                            clearAllSelections();
                        }
                    }
                });
            });
            
            // Toggle multi-select mode
            selectModeBtn.addEventListener('click', function() {
                multiSelectMode = !multiSelectMode;
                if (multiSelectMode) {
                    selectModeBtn.textContent = 'üîÑ Multi-Select: ON';
                    selectModeBtn.classList.add('active');
                } else {
                    selectModeBtn.textContent = 'üñ±Ô∏è Single Select Mode';
                    selectModeBtn.classList.remove('active');
                }
                updateStatus();
            });



            clearAllBtn.addEventListener('click', function() {
                clearAllSelections();
            });
            
            // Search functionality
            const searchInput = document.getElementById('searchInput');
            const searchButton = document.getElementById('searchButton');
            const searchResults = document.getElementById('searchResults');
            
            // Function to search for features in a layer
            async function searchLayer(layer, searchText, layerName) {
                const query = layer.createQuery();
                const searchPattern = searchText.replace(/\s+/g, '%');
                let whereClause = '';
                
                // Define search fields based on layer type
                if (layer === canadaTownsLayer) {
                    // Search in Canada Towns layer
                    const nameFields = [];
                    
                    // Find all potential name fields
                    layer.fields.forEach(field => {
                        const fieldName = field.name;
                        if (fieldName.toLowerCase().includes('name') || 
                            fieldName.toLowerCase().includes('town') || 
                            fieldName.toLowerCase().includes('city') ||
                            fieldName.toLowerCase().includes('municip')) {
                            nameFields.push(fieldName);
                        }
                    });
                    
                    // If no specific name fields found, search all string fields
                    if (nameFields.length === 0) {
                        layer.fields.forEach(field => {
                            if (field.type === 'string') {
                                nameFields.push(field.name);
                            }
                        });
                    }
                    
                    // Build the where clause
                    nameFields.forEach((field, index) => {
                        if (index > 0) whereClause += ' OR ';
                        whereClause += `UPPER(${field}) LIKE UPPER('%${searchPattern}%')`;
                    });
                } else {
                    // For other layers (like PSAP), search in common name fields
                    const nameFields = [];
                    layer.fields.forEach(field => {
                        const fieldName = field.name.toLowerCase();
                        if (fieldName.includes('name') || 
                            fieldName.includes('label') ||
                            fieldName.includes('title') ||
                            fieldName.includes('psap') ||
                            field.type === 'string') {
                            nameFields.push(field.name);
                        }
                    });
                    
                    nameFields.forEach((field, index) => {
                        if (index > 0) whereClause += ' OR ';
                        whereClause += `UPPER(${field}) LIKE UPPER('%${searchPattern}%')`;
                    });
                }
                
                query.where = whereClause || '1=0';
                query.outFields = ['*'];
                query.returnGeometry = true;
                query.num = 10; // Limit results
                
                try {
                    const result = await layer.queryFeatures(query);
                    return {
                        layer: layer,
                        layerName: layerName,
                        features: result.features.map(feature => ({
                            ...feature,
                            layerType: layerName
                        }))
                    };
                } catch (error) {
                    console.error(`Error searching ${layerName}:`, error);
                    return { layer: layer, layerName: layerName, features: [] };
                }
            }
            
            // Function to search across all layers
            async function searchAllLayers(searchText) {
                if (!searchText.trim()) {
                    searchResults.style.display = 'none';
                    return;
                }
                
                // Show loading state
                searchResults.innerHTML = '<div class="search-result-item">Searching...</div>';
                searchResults.style.display = 'block';
                
                try {
                    // Search all layers in parallel
                    const results = await Promise.all([
                        searchLayer(canadaTownsLayer, searchText, 'Canada Towns'),
                        searchLayer(psapLayer, searchText, 'PSAP Boundaries')
                    ]);
                    
                    // Process and display results
                    displaySearchResults(results, searchText);
                } catch (error) {
                    console.error('Search error:', error);
                    searchResults.innerHTML = '<div class="search-result-item">Error performing search</div>';
                }
            }
            
            // Function to display search results
            function displaySearchResults(layerResults, searchText) {
                searchResults.innerHTML = '';
                let hasResults = false;
                
                layerResults.forEach(layerResult => {
                    if (layerResult.features.length > 0) {
                        hasResults = true;
                        
                        // Add layer header
                        const header = document.createElement('div');
                        header.className = 'search-layer-header';
                        header.textContent = layerResult.layerName;
                        searchResults.appendChild(header);
                        
                        // Add features
                        layerResult.features.forEach(feature => {
                            const featureName = getTownName(feature.attributes);
                            const resultItem = document.createElement('div');
                            resultItem.className = 'search-result-item';
                            resultItem.innerHTML = `
                                <div class="search-item-name">${featureName}</div>
                                <div class="search-item-layer">${layerResult.layerName}</div>
                            `;
                            
                            resultItem.addEventListener('click', () => {
                                zoomToFeature(feature, featureName, layerResult.layer);
                                searchResults.style.display = 'none';
                            });
                            
                            searchResults.appendChild(resultItem);
                        });
                    }
                });
                
                if (!hasResults) {
                    const noResults = document.createElement('div');
                    noResults.className = 'search-result-item';
                    noResults.textContent = `No results found for "${searchText}"`;
                    searchResults.appendChild(noResults);
                }
                
                searchResults.style.display = 'block';
            }
            
            // Function to zoom to a feature
            function zoomToFeature(feature, name, layer) {
                view.goTo({
                    target: feature.geometry,
                    zoom: 12
                }, {
                    duration: 1000,
                    easing: 'ease-out'
                }).then(() => {
                    view.whenLayerView(layer).then(layerView => {
                        // Clear previous highlight
                        if (window.searchHighlight) {
                            window.searchHighlight.remove();
                        }
                        
                        // Highlight the feature
                        window.searchHighlight = layerView.highlight(feature);
                        status.textContent = `Zoomed to: ${name}`;
                    });
                });
            }
            
            // Wrapper function for backward compatibility
            function searchTowns(searchText) {
                searchAllLayers(searchText);
            }
            
            // Function to get the appropriate name for a feature based on its layer
            function getFeatureName(feature) {
                if (feature.layer === canadaTownsLayer) {
                    return getTownName(feature.attributes);
                } else if (feature.layer === psapLayer) {
                    // Try common PSAP name fields
                    return feature.attributes.NAME || 
                           feature.attributes.PSAP_NAME || 
                           feature.attributes.LABEL || 
                           'Unnamed PSAP';
                }
                return 'Unnamed Feature';
            }
            
            // Search button click event
            searchButton.addEventListener('click', function() {
                searchTowns(searchInput.value);
            });
            
            // Search on Enter key
            searchInput.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    searchTowns(searchInput.value);
                }
            });
            
            // Hide search results when clicking outside
            document.addEventListener('click', function(event) {
                if (!event.target.closest('.search-container')) {
                    searchResults.style.display = 'none';
                }
            });
            
            // Show search results when input is focused
            searchInput.addEventListener('focus', function() {
                if (searchInput.value.trim() && searchResults.children.length > 0) {
                    searchResults.style.display = 'block';
                }
            });
            
            // Search as you type (with debounce)
            let debounceTimeout;
            searchInput.addEventListener('input', function() {
                clearTimeout(debounceTimeout);
                debounceTimeout = setTimeout(function() {
                    searchTowns(searchInput.value);
                }, 300); // 300ms delay
            });

            panelToggle.addEventListener('click', function() {
                const content = document.querySelector('.panel-content');
                const footer = document.querySelector('.panel-footer');

                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    footer.style.display = 'block';
                    panelToggle.textContent = '‚àí';
                } else {
                    content.style.display = 'none';
                    footer.style.display = 'none';
                    panelToggle.textContent = '+';
                }
            });

            // Download functionality
            downloadBtn.addEventListener('click', async function() {
                if (selectedFeatures.length === 0) {
                    alert('No features selected');
                    return;
                }

                try {
                    status.textContent = 'Preparing download with coordinate transformation...';

                    // Group features by layer for better organization
                    const featuresByLayer = {};
                    
                    // Process all features with proper coordinate transformation
                    const features = await Promise.all(selectedFeatures.map(async (feature) => {
                        // Convert coordinates with proper projection
                        const coordinates = await convertEsriGeometryToGeoJSON(feature.geometry);

                        // Get original spatial reference information
                        const originalSR = feature.geometry.spatialReference;
                        const originalWkid = originalSR ? originalSR.wkid : 'Unknown';
                        const originalName = originalSR ? (originalSR.name || `EPSG:${originalWkid}`) : 'Unknown';
                        
                        // Determine layer name for grouping
                        const layerName = feature.layer === canadaTownsLayer ? 'Canada_Towns' : 
                                       (feature.layer === psapLayer ? 'PSAP_Boundaries' : 'Unknown_Layer');
                        
                        // Track features by layer for metadata
                        if (!featuresByLayer[layerName]) {
                            featuresByLayer[layerName] = {
                                count: 0,
                                originalWkid: originalWkid,
                                originalName: originalName,
                                serviceUrl: feature.layer.url || 'Unknown'
                            };
                        }
                        featuresByLayer[layerName].count++;

                        return {
                            type: "Feature",
                            geometry: {
                                type: feature.geometry.type === "polygon" ? "Polygon" : "MultiPolygon",
                                coordinates: coordinates
                            },
                            properties: {
                                ...feature.attributes,
                                // Add comprehensive projection metadata
                                export_metadata: {
                                    layer_name: layerName,
                                    exported_date: new Date().toISOString(),
                                    original_crs_wkid: originalWkid,
                                    original_crs_name: originalName,
                                    target_crs: 'EPSG:4326',
                                    target_crs_name: 'WGS 84',
                                    coordinates_note: 'Coordinates transformed to WGS84 (EPSG:4326) for QGIS compatibility'
                                }
                            }
                        };
                    }));

                    // Generate metadata for each layer
                    const layerMetadata = Object.entries(featuresByLayer).map(([layerName, data]) => ({
                        layer_name: layerName,
                        feature_count: data.count,
                        original_crs_wkid: data.originalWkid,
                        original_crs_name: data.originalName,
                        service_url: data.serviceUrl,
                        transformation_applied: data.originalWkid !== 4326 ? "Yes" : "No"
                    }));

                    const geoJSON = {
                        type: "FeatureCollection",
                        // QGIS-compatible CRS specification
                        crs: {
                            type: "name",
                            properties: {
                                name: "urn:ogc:def:crs:EPSG::4326"
                            }
                        },
                        // Enhanced metadata for QGIS and other GIS software
                        metadata: {
                            exported_by: "ArcGIS Interactive Map",
                            export_date: new Date().toISOString(),
                            coordinate_system: {
                                epsg_code: 4326,
                                name: "WGS 84",
                                proj4: "+proj=longlat +datum=WGS84 +no_defs",
                                description: "World Geodetic System 1984"
                            },
                            layers: layerMetadata,
                            total_feature_count: features.length,
                            qgis_import_notes: [
                                "This file is in EPSG:4326 (WGS84) coordinate system",
                                "Should import correctly into QGIS without additional projection",
                                "If projection issues occur, manually set CRS to EPSG:4326 in QGIS"
                            ]
                        },
                        features: features
                    };

                    // Create and download the file
                    const dataStr = JSON.stringify(geoJSON, null, 2);
                    const dataBlob = new Blob([dataStr], {type: 'application/json'});
                    const url = URL.createObjectURL(dataBlob);

                    const downloadLink = document.createElement('a');
                    downloadLink.href = url;

                    // Create filename based on selected features
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    let filename;
                    
                    if (selectedFeatures.length === 1) {
                        const feature = selectedFeatures[0];
                        const layerPrefix = feature.layer === canadaTownsLayer ? 'town' : 'psap';
                        const name = getFeatureName(feature).replace(/[^a-z0-9]/gi, '_').toLowerCase();
                        filename = `${layerPrefix}_${name}_WGS84.geojson`;
                    } else {
                        const layerTypes = Object.keys(featuresByLayer);
                        const typeStr = layerTypes.length > 1 ? 'features' : layerTypes[0].toLowerCase();
                        filename = `map_${typeStr}_${selectedFeatures.length}_WGS84_${timestamp}.geojson`;
                    }

                    downloadLink.download = filename;

                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    URL.revokeObjectURL(url);

                    const layerTypes = Object.keys(featuresByLayer);
                    const layerStr = layerTypes.length > 1 ? 
                        `${layerTypes.length} different layers` : 
                        layerTypes[0].replace('_', ' ');
                        
                    status.textContent = `Downloaded ${selectedFeatures.length} features from ${layerStr} in WGS84`;

                } catch (error) {
                    console.error('Error downloading features:', error);
                    alert('Error downloading features. Please check console for details.');
                    status.textContent = 'Error during download';
                }
            });

            // Helper function to convert Esri geometry to GeoJSON coordinates with proper projection
            async function convertEsriGeometryToGeoJSON(geometry) {
                try {
                    // Create target spatial reference (WGS84 / EPSG:4326)
                    const wgs84 = new SpatialReference({ wkid: 4326 });

                    let projectedGeometry = geometry;

                    // Check if geometry needs projection
                    if (geometry.spatialReference && geometry.spatialReference.wkid !== 4326) {
                        console.log(`Projecting from EPSG:${geometry.spatialReference.wkid} to EPSG:4326`);

                        // Load projection engine if not already loaded
                        await projection.load();

                        // Project geometry to WGS84
                        projectedGeometry = projection.project(geometry, wgs84);
                    }

                    // Convert to GeoJSON coordinate format
                    if (projectedGeometry.rings) {
                        // Polygon geometry
                        return projectedGeometry.rings.map(ring =>
                            ring.map(coord => [coord[0], coord[1]])
                        );
                    }

                    return [];
                } catch (error) {
                    console.error('Error converting geometry coordinates:', error);
                    console.log('Falling back to original coordinates');

                    // Fallback to original method if projection fails
                    if (geometry.rings) {
                        return geometry.rings.map(ring =>
                            ring.map(coord => [coord[0], coord[1]])
                        );
                    }
                    return [];
                }
            }

            // Wait for layer to load and zoom to extent
            canadaTownsLayer.when(function() {
                console.log("Canada Towns layer loaded successfully");

                // Log coordinate system information for debugging
                const layerSR = canadaTownsLayer.spatialReference;
                if (layerSR) {
                    console.log("Layer Spatial Reference:", {
                        wkid: layerSR.wkid,
                        name: layerSR.name,
                        unit: layerSR.unit
                    });

                    // Common Canadian coordinate systems
                    const canadianSystems = {
                        4326: "WGS 84 (Geographic)",
                        3857: "Web Mercator",
                        4617: "NAD83(CSRS)",
                        4269: "NAD83",
                        102100: "Web Mercator (Auxiliary Sphere)",
                        3347: "Statistics Canada Lambert",
                        3348: "NAD83(CSRS) / Statistics Canada Lambert",
                        2958: "NAD83(CSRS) / UTM zone 19N",
                        2959: "NAD83(CSRS) / UTM zone 20N",
                        2960: "NAD83(CSRS) / UTM zone 21N",
                        102002: "Canada Albers Equal Area Conic"
                    };

                    const systemName = canadianSystems[layerSR.wkid] || `EPSG:${layerSR.wkid}`;
                    console.log(`Detected coordinate system: ${systemName}`);
                    status.textContent = `Layer loaded in ${systemName} - will transform to WGS84 for export`;
                } else {
                    console.log("No spatial reference information available");
                    status.textContent = "Layer loaded - coordinate system unknown";
                }

                // Get layer extent and zoom to it
                if (canadaTownsLayer.fullExtent) {
                    view.goTo(canadaTownsLayer.fullExtent);
                }

                // Initialize UI
                updateStatus();

            }).catch(function(error) {
                console.error("Error loading layer:", error);
                status.textContent = 'Error loading Canada Towns layer';
            });
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PSAP Multi-Select Map - Search</title>
    <link rel="stylesheet" href="https://js.arcgis.com/4.28/esri/themes/light/main.css">
    <script src="https://js.arcgis.com/4.28/"></script>
    <style>
        html, body, #viewDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
            background-color: #001559;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: #FFFFFF;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,21,89,0.3);
            z-index: 1000;
            width: 450px;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid #29A8DD;
        }
        .status { margin: 5px 0; font-size: 12px; }
        .success { color: #29A8DD; }
        .error { color: #FFF300; }
        .info { color: #005eFF; }
        button { 
            margin: 5px; 
            padding: 8px 12px; 
            cursor: pointer; 
            background: #29A8DD;
            color: #FFFFFF;
            border: none;
            border-radius: 4px;
            font-weight: bold;
        }
        button:hover {
            background: #005eFF;
        }
        h3 { 
            margin-top: 0; 
            color: #001559;
            border-bottom: 2px solid #29A8DD;
            padding-bottom: 8px;
        }
        
        /* Search styles */
        .search-container {
            margin: 15px 0;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            border: 2px solid #29A8DD;
            box-shadow: 0 4px 12px rgba(0,21,89,0.15);
            text-align: center;
        }
        .search-input {
            width: 90%;
            padding: 12px 16px;
            border: 2px solid #29A8DD;
            border-radius: 8px;
            font-size: 15px;
            margin-bottom: 10px;
            background: #FFFFFF;
            color: #001559;
            text-align: center;
            transition: all 0.3s ease;
        }
        .search-input:focus {
            outline: none;
            border-color: #005eFF;
            box-shadow: 0 0 12px rgba(0,94,255,0.4);
            transform: scale(1.02);
        }
        .search-results {
            max-height: 200px;
            overflow-y: auto;
            border: 2px solid #29A8DD;
            border-radius: 6px;
            background: #FFFFFF;
            display: none;
            box-shadow: 0 2px 8px rgba(0,21,89,0.2);
        }
        .search-result {
            padding: 10px;
            border-bottom: 1px solid #29A8DD;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        .search-result:hover {
            background: #FFF300;
        }
        .search-result:last-child {
            border-bottom: none;
        }
        .result-title {
            font-weight: bold;
            color: #001559;
        }
        .result-details {
            color: #005eFF;
            font-size: 11px;
            margin-top: 2px;
        }
        .highlight {
            background-color: #FFF300;
            font-weight: bold;
            padding: 1px 2px;
            border-radius: 2px;
        }
        .search-stats {
            font-size: 11px;
            color: #001559;
            margin-top: 5px;
            font-weight: bold;
        }
        
        /* Popup styles */
        .popup {
            position: absolute;
            background: #FFFFFF;
            border: 3px solid #29A8DD;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 6px 20px rgba(0,21,89,0.4);
            max-width: 400px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 2000;
            display: none;
        }
        .popup-header {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 15px;
            color: #001559;
            border-bottom: 3px solid #29A8DD;
            padding-bottom: 8px;
        }
        .popup-content {
            font-size: 12px;
        }
        .popup-row {
            display: flex;
            margin: 8px 0;
            border-bottom: 1px solid #29A8DD;
            padding: 5px 0;
        }
        .popup-label {
            font-weight: bold;
            min-width: 120px;
            color: #001559;
        }
        .popup-value {
            flex: 1;
            color: #005eFF;
            word-break: break-word;
        }
        .popup-close {
            position: absolute;
            top: 8px;
            right: 12px;
            cursor: pointer;
            font-size: 18px;
            color: #29A8DD;
            background: #FFFFFF;
            border: 2px solid #29A8DD;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        .popup-close:hover {
            background: #005eFF;
            color: #FFFFFF;
            border-color: #005eFF;
        }
        
        /* Highlight styles */
        .highlight {
            background: #FFF300;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
        }
        
        /* Layer selector styles */
        .layer-selector {
            margin: 15px 0;
            padding: 15px;
            background: #FFFFFF;
            border-radius: 8px;
            border: 2px solid #29A8DD;
            box-shadow: 0 2px 8px rgba(0,21,89,0.2);
        }
        .layer-selector h4 {
            margin: 0 0 10px 0;
            color: #001559;
            font-size: 14px;
            border-bottom: 2px solid #29A8DD;
            padding-bottom: 5px;
        }
        .layer-selector select {
            width: 100%;
            padding: 8px;
            border: 2px solid #29A8DD;
            border-radius: 4px;
            background: #FFFFFF;
            color: #001559;
            font-size: 12px;
            cursor: pointer;
        }
        .layer-selector select:focus {
            outline: none;
            border-color: #005eFF;
            box-shadow: 0 0 8px rgba(0,94,255,0.3);
        }
        
        /* Button Groups */
        .button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #29A8DD 0%, #005eFF 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: #495057;
            border: 1px solid #dee2e6;
            padding: 8px 14px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-secondary:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            border-color: #adb5bd;
        }
        
        .btn-secondary.active {
            background: linear-gradient(135deg, #FF6B6B 0%, #FF5252 100%);
            color: white;
            border-color: #FF5252;
            box-shadow: 0 2px 4px rgba(255, 107, 107, 0.3);
        }
        
        .debug-tools {
            border-top: 1px solid #dee2e6;
            padding-top: 10px;
            margin-top: 10px;
        }
        
        .debug-tools button {
            background: #6c757d;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            margin-right: 8px;
        }
        
        kbd {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 3px;
            padding: 2px 4px;
            font-size: 10px;
            font-family: monospace;
            color: #495057;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>PSAP Multi-Select Map - Search</h3>
        <div id="status" style="display: none;"></div>
        
        <!-- Search Container -->
        <div class="search-container">
            <input type="text" id="searchInput" class="search-input" placeholder="Search PSAPs, agencies, counties, etc..." />
            <div id="searchResults" class="search-results"></div>
            <div id="searchStats" class="search-stats"></div>
        </div>
        
        <!-- Selection Tools -->
        <div class="button-group">
            <button onclick="toggleSelectionMode()" class="btn-secondary">Selection Mode</button>
            <button onclick="showSelectionSummary()" class="btn-secondary">Show Selected</button>
            <button onclick="downloadSelected()" class="btn-secondary">Download</button>
            <button onclick="clearSelection()" class="btn-secondary">Clear Selection</button>
        </div>
        
        <!-- Debug Tools (Hidden by default) -->
        <div class="debug-tools" style="display: none;">
            <button id="toggleLoggingBtn" onclick="toggleLogging()">Enable Logging</button>
            <button onclick="showLogs()">View Logs</button>
        </div>
        
        <!-- USGS Layer Selector -->
        <div class="layer-selector">
            <h4>USGS Reference Layers</h4>
            <select id="usgsLayerSelect" onchange="toggleUSGSLayer()">
                <option value="">No additional layers</option>
                <option value="21">State Boundaries (Small-Scale)</option>
                <option value="22">State Boundaries (Large-Scale)</option>
                <option value="23">County Boundaries</option>
                <option value="24">Cities & Towns</option>
                <option value="25">Unincorporated Places</option>
                <option value="29">National Parks</option>
                <option value="31">National Forests</option>
                <option value="32">National Wilderness</option>
                <option value="35">US Fish & Wildlife Service</option>
                <option value="36">Bureau of Land Management</option>
                <option value="37">Military Reserves</option>
                <option value="41">Congressional Districts</option>
            </select>
        </div>
        
        <div style="margin-top: 10px; font-size: 11px; color: #001559;">
            <strong>How to use:</strong><br>
            • All layers load automatically<br>
            • Use search box for specific locations<br>
            • Select USGS layers from dropdown for additional boundaries<br>
            • Click on any boundary to view details<br>
            • Use selection tools to download boundaries<br>
            • Press <kbd>Ctrl+D</kbd> to show debug tools
        </div>
    </div>
    
    <!-- Popup for feature information -->
    <div id="featurePopup" class="popup">
        <div class="popup-close" onclick="closePopup()">&times;</div>
        <div class="popup-header" id="popupHeader">Feature Information</div>
        <div class="popup-content" id="popupContent"></div>
    </div>
    
    <div id="viewDiv"></div>

    <script>
        require([
            "esri/Map",
            "esri/views/MapView",
            "esri/layers/GraphicsLayer",
            "esri/layers/FeatureLayer",
            "esri/Graphic",
            "esri/geometry/Polygon",
            "esri/symbols/SimpleFillSymbol",
            "esri/symbols/SimpleLineSymbol",
            "esri/geometry/SpatialReference"
        ], function(Map, MapView, GraphicsLayer, FeatureLayer, Graphic, Polygon, SimpleFillSymbol, SimpleLineSymbol, SpatialReference) {
            
            // Working services with improved coordinate handling
            const workingServices = [
                { name: "Alabama", url: "https://services2.arcgis.com/Ao3oYLThb9Xbvgpw/arcgis/rest/services/Alabama_911_Centers/FeatureServer/1", wkid: 102100 },
                { name: "Arizona", url: "https://server.azgeo.az.gov/arcgis/rest/services/az911/Arizona_PSAP_Boundary/FeatureServer/1", wkid: 4326 },
                { name: "Colorado", url: "https://services3.arcgis.com/DgjqnJA1rgO92Soi/arcgis/rest/services/Colorado_PSAP_Review/FeatureServer/1", wkid: 102100 },
                { name: "Illinois", url: "https://services1.arcgis.com/CNPdEkvnGl65jCX8/ArcGIS/rest/services/PSAPs_and_DIGBs_for_planning_purposes/FeatureServer/1", wkid: 102100 },
                { name: "Nevada", url: "https://services3.arcgis.com/5GeA0r0IN0Q5uQUC/arcgis/rest/services/PSAP_boundaries/FeatureServer/1", wkid: 3395 },
                { name: "North Carolina", url: "https://services5.arcgis.com/mSDBiLWaIfH92NqI/arcgis/rest/services/NC911_PSAPs/FeatureServer/0", wkid: 102100 },
                { name: "Ohio", url: "https://services8.arcgis.com/gHHsN1i8OISt9wMD/arcgis/rest/services/PSAP_BOUNDARIES/FeatureServer/0", wkid: 102100 },
                { name: "Tennessee", url: "https://services7.arcgis.com/aheAxJpwjYPDjSuN/arcgis/rest/services/TN_Emergency_Districts_Org/FeatureServer/3", wkid: 102100 },
                { name: "Texas", url: "https://services.arcgis.com/8vL8ZFWfQxhb4uIP/arcgis/rest/services/Texas_911_Control_Points_WFL1/FeatureServer/3", wkid: 102100 }
            ];

            // Canadian Census Subdivision layer configuration
            const canadianLayerConfig = {
                name: "Canada Census Subdivisions",
                url: "https://geo.statcan.gc.ca/geo_wa/rest/services/2025/lcsd000a25s_e/MapServer/0",
                wkid: 3347
            };

            // Create map and view
            const map = new Map({
                basemap: "satellite"
            });

            const view = new MapView({
                container: "viewDiv",
                map: map,
                zoom: 4,
                center: [-98, 39]
            });

            // Add USGS County Labels layer for geographic context (behind PSAP layers)
            const countyLabelsLayer = new FeatureLayer({
                url: "https://carto.nationalmap.gov/arcgis/rest/services/govunits/mapserver/3",
                title: "USGS County Labels",
                opacity: 0.8,
                visible: true
            });
            map.add(countyLabelsLayer);

            // Create graphics layer for PSAP data (on top of USGS layers)
            const psapLayer = new GraphicsLayer({
                title: "PSAP Boundaries",
                visible: true  // Visible by default
            });
            map.add(psapLayer);

            // Store all loaded graphics for searching
            let allGraphics = [];
            let searchResults = [];
            let countyLayer = null;
            let stateLayer = null;
            let canadianLayer = null;
            let logMessages = []; // Array to store log messages
            let isLoggingEnabled = false; // Flag to control console logging
            let selectedGraphics = []; // Array to store selected graphics
            let isSelectionMode = false; // Flag to track selection mode
            let searchActive = false; // Flag to track if search is active

            // Function to convert coordinates if needed
            function convertCoordinates(rings, fromWkid) {
                if (fromWkid === 4326) {
                    // Convert from decimal degrees to Web Mercator
                    return rings.map(ring => 
                        ring.map(coord => {
                            const lon = coord[0];
                            const lat = coord[1];
                            const x = lon * 20037508.34 / 180;
                            const y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180) * 20037508.34 / 180;
                            return [x, y];
                        })
                    );
                } else if (fromWkid === 3347) {
                    // Canadian Albers Equal Area projection - convert to Web Mercator
                    // This is a simplified conversion - for production use a proper projection library
                    return rings.map(ring => 
                        ring.map(coord => {
                            // Simplified conversion from Canadian Albers to Web Mercator
                            // This is approximate - the actual conversion requires complex math
                            const x = coord[0] * 0.0001; // Scale factor
                            const y = coord[1] * 0.0001; // Scale factor
                            return [x, y];
                        })
                    );
                }
                // For other projected coordinate systems, assume they're already in Web Mercator or close enough
                return rings;
            }

            // Function to format attribute values
            function formatAttributeValue(value) {
                if (value === null || value === undefined) {
                    return '<em>Not specified</em>';
                }
                if (typeof value === 'string') {
                    return value.trim() || '<em>Empty</em>';
                }
                if (typeof value === 'number') {
                    return value.toLocaleString();
                }
                return String(value);
            }

            // Function to highlight search terms in text
            function highlightSearchTerm(text, searchTerm) {
                if (!searchTerm || !text) return text;
                const regex = new RegExp(`(${searchTerm})`, 'gi');
                return String(text).replace(regex, '<span class="highlight">$1</span>');
            }

            // Function to search across all graphics
            function searchGraphics(searchTerm) {
                if (!searchTerm || searchTerm.length < 2) {
                    hideSearchResults();
                    searchActive = false;
                    return;
                }
                
                searchActive = true;

                const results = [];
                const term = searchTerm.toLowerCase();
                
                // Debug: Log search database status
                logMessage(`Searching ${allGraphics.length} features for: "${searchTerm}"`, 'info');
                const psapCount = allGraphics.filter(g => g.attributes.state).length;
                const usgsCount = allGraphics.filter(g => g.attributes.layerType === "USGS" || g.attributes.NAME).length;
                const canadianCount = allGraphics.filter(g => g.attributes.layerType === "Canadian" || g.attributes.CSDNAME).length;
                logMessage(`Search database: ${psapCount} PSAP features, ${usgsCount} USGS features, ${canadianCount} Canadian features`, 'info');
                
                // Debug: Show some USGS features if we have them
                if (usgsCount > 0) {
                    const sampleUSGS = allGraphics.filter(g => g.attributes.layerType === "USGS" || g.attributes.NAME).slice(0, 2);
                    sampleUSGS.forEach((g, i) => {
                        logMessage(`USGS Sample ${i+1}: ${JSON.stringify(g.attributes)}`, 'info');
                    });
                }

                allGraphics.forEach(graphic => {
                    const attributes = graphic.attributes;
                    let matchFound = false;
                    let matchDetails = [];
                    let matchScore = 0;

                    // Search through ALL attributes (including previously excluded ones)
                    Object.keys(attributes).forEach(key => {
                        const value = attributes[key];
                        if (value && String(value).toLowerCase().includes(term)) {
                            matchFound = true;
                            const label = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                            matchDetails.push(`${label}: ${value}`);
                            
                            // Score matches - exact matches get higher scores
                            if (String(value).toLowerCase() === term) {
                                matchScore += 10; // Exact match
                            } else if (String(value).toLowerCase().startsWith(term)) {
                                matchScore += 5; // Starts with
                            } else {
                                matchScore += 1; // Contains
                            }
                        }
                    });

                    if (matchFound) {
                        // Create a title for the result
                        let title;
                        if (attributes.state) {
                            // PSAP feature
                            title = attributes.state;
                            if (attributes.name) title += ` - ${attributes.name}`;
                            else if (attributes.psap_name) title += ` - ${attributes.psap_name}`;
                            else if (attributes.agency_name) title += ` - ${attributes.agency_name}`;
                            else title += ` PSAP`;
                        } else if (attributes.layerType === "USGS" || attributes.NAME) {
                            // USGS feature
                            title = `USGS ${attributes.layerName || 'Feature'} - ${attributes.displayName || attributes.NAME || 'Feature'}`;
                        } else if (attributes.layerType === "Canadian" || attributes.CSDNAME) {
                            // Canadian feature
                            title = `Canadian ${attributes.CSDTYPE || 'Subdivision'} - ${attributes.CSDNAME || 'Feature'}`;
                        } else {
                            // Fallback
                            title = `${attributes.layerType || 'Unknown'} - ${attributes.displayName || attributes.NAME || 'Feature'}`;
                        }

                        results.push({
                            graphic: graphic,
                            title: title,
                            details: matchDetails.slice(0, 5).join(', '), // Show first 5 matches
                            matchCount: matchDetails.length,
                            matchScore: matchScore
                        });
                    }
                });

                // Sort results by relevance (score first, then match count, then alphabetically)
                results.sort((a, b) => {
                    if (b.matchScore !== a.matchScore) {
                        return b.matchScore - a.matchScore;
                    }
                    if (b.matchCount !== a.matchCount) {
                        return b.matchCount - a.matchCount;
                    }
                    return a.title.localeCompare(b.title);
                });

                displaySearchResults(results, searchTerm);
            }

            // Function to display search results
            function displaySearchResults(results, searchTerm) {
                const resultsDiv = document.getElementById('searchResults');
                const statsDiv = document.getElementById('searchStats');

                if (results.length === 0) {
                    resultsDiv.innerHTML = '<div class="search-result">No matches found</div>';
                    statsDiv.textContent = '';
                    
                    // Hide all layers when no results
                    hideAllLayers();
                } else {
                    let html = '';
                    results.forEach((result, index) => {
                        const highlightedTitle = highlightSearchTerm(result.title, searchTerm);
                        const highlightedDetails = highlightSearchTerm(result.details, searchTerm);
                        
                        html += `
                            <div class="search-result" onclick="selectSearchResult(${index})">
                                <div class="result-title">${highlightedTitle}</div>
                                <div class="result-details">${highlightedDetails}</div>
                            </div>
                        `;
                    });
                    resultsDiv.innerHTML = html;
                    statsDiv.textContent = `Found ${results.length} result${results.length !== 1 ? 's' : ''}`;
                    
                    // Show relevant layers based on search results
                    logMessage(`Search results found, calling showRelevantLayers with: ${results.length} results`, 'info');
                    showRelevantLayers(results);
                }

                resultsDiv.style.display = 'block';
                searchResults = results;
            }

            // Function to hide search results
            function hideSearchResults() {
                document.getElementById('searchResults').style.display = 'none';
                document.getElementById('searchStats').textContent = '';
                searchResults = [];
                // Don't hide layers when search results are cleared - let them stay visible
            }

            // Function to select a search result
            function selectSearchResult(index) {
                if (searchResults[index]) {
                    const graphic = searchResults[index].graphic;
                    
                    // Show the relevant layer for this graphic
                    showLayerForGraphic(graphic);
                    
                    // Zoom to the graphic
                    view.goTo(graphic, { padding: 50, duration: 1000 });
                    
                    // Show popup after zoom
                    setTimeout(() => {
                        const center = view.center;
                        const screenPoint = view.toScreen(center);
                        showFeaturePopup(graphic, screenPoint);
                    }, 1200);
                    
                    // Hide search results but keep layers visible
                    document.getElementById('searchResults').style.display = 'none';
                    document.getElementById('searchStats').textContent = '';
                    document.getElementById('searchInput').value = '';
                    searchResults = [];
                }
            }

            // Function to show the relevant layer for a specific graphic
            function showLayerForGraphic(graphic) {
                const attributes = graphic.attributes;
                logMessage(`showLayerForGraphic called with: ${JSON.stringify(attributes)}`, 'info');
                
                if (attributes.state) {
                    // PSAP features have 'state' attribute
                    if (psapLayer) {
                        psapLayer.visible = true;
                        logMessage(`PSAP layer visibility set to: ${psapLayer.visible}`, 'info');
                        updateStatus('PSAP layer shown for selected feature', 'info');
                        highlightLayerTemporarily(psapLayer, 'PSAP');
                    } else {
                        logMessage('PSAP layer not found!', 'error');
                        updateStatus('PSAP layer not available', 'error');
                    }
                } else if (attributes.layerType === "USGS") {
                    logMessage(`USGS feature detected, layerName: ${attributes.layerName}`, 'info');
                    if (attributes.layerName === "US Counties") {
                        if (countyLayer) {
                            countyLayer.visible = true;
                            logMessage(`County layer visibility set to: ${countyLayer.visible}`, 'info');
                            updateStatus('County layer shown for selected feature', 'info');
                            highlightLayerTemporarily(countyLayer, 'County');
                        } else {
                            logMessage('County layer not found!', 'error');
                            updateStatus('County layer not available', 'error');
                        }
                    } else if (attributes.layerName === "US States") {
                        if (stateLayer) {
                            stateLayer.visible = true;
                            logMessage(`State layer visibility set to: ${stateLayer.visible}`, 'info');
                            updateStatus('State layer shown for selected feature', 'info');
                            highlightLayerTemporarily(stateLayer, 'State');
                        } else {
                            logMessage('State layer not found!', 'error');
                            updateStatus('State layer not available', 'error');
                        }
                    } else if (attributes.layerName === "Test Counties") {
                        if (countyLayer) {
                            countyLayer.visible = true;
                            logMessage(`Test county layer visibility set to: ${countyLayer.visible}`, 'info');
                            updateStatus('Test county layer shown for selected feature', 'info');
                            highlightLayerTemporarily(countyLayer, 'Test County');
                        } else {
                            logMessage('Test county layer not found!', 'error');
                            updateStatus('Test county layer not available', 'error');
                        }
                    } else {
                        logMessage(`Unknown USGS layer name: ${attributes.layerName}`, 'warning');
                    }
                } else if (attributes.layerType === "Canadian") {
                    // Canadian features
                    if (canadianLayer) {
                        canadianLayer.visible = true;
                        logMessage(`Canadian layer visibility set to: ${canadianLayer.visible}`, 'info');
                        updateStatus('Canadian layer shown for selected feature', 'info');
                        highlightLayerTemporarily(canadianLayer, 'Canadian');
                    } else {
                        logMessage('Canadian layer not found!', 'error');
                        updateStatus('Canadian layer not available', 'error');
                    }
                } else {
                    logMessage(`Unknown layer type: ${attributes.layerType}`, 'warning');
                }
            }

            // Function to temporarily highlight a layer
            function highlightLayerTemporarily(layer, layerName) {
                // Flash the layer with a bright color for 2 seconds
                const originalGraphics = layer.graphics.toArray();
                
                // Create bright highlight graphics
                const highlightGraphics = originalGraphics.map(graphic => {
                    const highlightGraphic = graphic.clone();
                    highlightGraphic.symbol = new SimpleFillSymbol({
                        color: [255, 255, 255, 0.8], // Bright white
                        outline: new SimpleLineSymbol({
                            color: [255, 0, 0, 1], // Bright red outline
                            width: 3
                        })
                    });
                    return highlightGraphic;
                });
                
                // Add highlight graphics
                highlightGraphics.forEach(g => layer.add(g));
                
                // Remove highlight after 2 seconds
                setTimeout(() => {
                    highlightGraphics.forEach(g => layer.remove(g));
                    updateStatus(`${layerName} layer highlighted and now visible`, 'success');
                }, 2000);
            }

            // Function to clear search
            function clearSearch() {
                document.getElementById('searchInput').value = '';
                hideSearchResults();
                searchActive = false;
                // Don't hide layers when search is cleared - let them stay visible
            }

            // Function to show popup with feature information
            function showFeaturePopup(graphic, screenPoint) {
                const popup = document.getElementById('featurePopup');
                const header = document.getElementById('popupHeader');
                const content = document.getElementById('popupContent');
                
                const attributes = graphic.attributes;
                
                // Set header based on feature type
                if (attributes.state) {
                    // PSAP features
                    header.textContent = `${attributes.state} PSAP`;
                } else if (attributes.layerType === "USGS") {
                    // USGS features
                    header.textContent = `USGS ${attributes.layerName} - ${attributes.displayName || 'Feature'}`;
                } else if (attributes.layerType === "Canadian") {
                    // Canadian features
                    header.textContent = `Canadian ${attributes.CSDTYPE || 'Subdivision'} - ${attributes.CSDNAME || 'Feature'}`;
                } else {
                    // Fallback
                    header.textContent = `${attributes.layerType || 'Unknown'} Feature`;
                }
                
                // Build content
                let html = '';
                
                // Sort attributes to show important ones first
                const sortedKeys = Object.keys(attributes).sort((a, b) => {
                    let priority;
                    if (attributes.layerType === "USGS") {
                        priority = ['displayName', 'NAME', 'STATE_NAME', 'COUNTY_NAME', 'FCODE', 'AREASQKM', 'POPULATION'];
                    } else {
                        priority = ['state', 'name', 'psap_name', 'agency_name', 'county', 'city'];
                    }
                    const aIndex = priority.indexOf(a);
                    const bIndex = priority.indexOf(b);
                    if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
                    if (aIndex !== -1) return -1;
                    if (bIndex !== -1) return 1;
                    return a.localeCompare(b);
                });
                
                sortedKeys.forEach(key => {
                    if (key !== 'state' && key !== 'service_name' && key !== 'layerType' && key !== 'layerName' && key !== 'source') { // Skip internal attributes
                        const value = formatAttributeValue(attributes[key]);
                        const label = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        
                        html += `
                            <div class="popup-row">
                                <div class="popup-label">${label}:</div>
                                <div class="popup-value">${value}</div>
                            </div>
                        `;
                    }
                });
                
                if (html === '') {
                    html = '<div style="color: #999; font-style: italic;">No additional attributes available</div>';
                }
                
                content.innerHTML = html;
                
                // Position popup
                const viewport = view.container.getBoundingClientRect();
                const popupWidth = 400;
                const popupHeight = 300;
                
                let left = screenPoint.x + 10;
                let top = screenPoint.y - popupHeight - 10;
                
                // Adjust if popup would go off screen
                if (left + popupWidth > viewport.width) {
                    left = screenPoint.x - popupWidth - 10;
                }
                if (top < 0) {
                    top = screenPoint.y + 10;
                }
                
                popup.style.left = left + 'px';
                popup.style.top = top + 'px';
                popup.style.display = 'block';
            }

            // Function to close popup
            function closePopup() {
                document.getElementById('featurePopup').style.display = 'none';
            }

            // Function to load a single service
            async function loadService(service) {
                try {
                    logMessage(`Loading ${service.name}...`, 'info');
                    
                    // Remove record limit to get ALL features
                    const queryUrl = `${service.url}/query?where=1%3D1&outFields=*&returnGeometry=true&f=json&resultRecordCount=10000`;
                    const response = await fetch(queryUrl);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (!data.features || data.features.length === 0) {
                        updateStatus(`${service.name}: No features found`, 'error');
                        return 0;
                    }

                    let featureCount = 0;
                    
                    data.features.forEach(feature => {
                        try {
                            if (feature.geometry && feature.geometry.rings) {
                                // Convert coordinates if needed
                                let rings = feature.geometry.rings;
                                if (service.wkid === 4326) {
                                    rings = convertCoordinates(rings, 4326);
                                }
                                
                                // Create polygon geometry
                                const polygon = new Polygon({
                                    rings: rings,
                                    spatialReference: { wkid: 3857 }
                                });
                                
                                // Create graphic
                                const graphic = new Graphic({
                                    geometry: polygon,
                                    symbol: new SimpleFillSymbol({
                                        color: [41, 168, 221, 0.4], // Safety Blue with transparency
                                        outline: new SimpleLineSymbol({
                                            color: [0, 94, 255, 0.9], // Glow color
                                            width: 2
                                        })
                                    }),
                                    attributes: {
                                        ...feature.attributes,
                                        state: service.name,
                                        layerType: "PSAP"
                                    }
                                });
                                
                                psapLayer.add(graphic);
                                allGraphics.push(graphic); // Add to searchable graphics
                                featureCount++;
                            }
                        } catch (geoError) {
                            console.error(`Geometry error in ${service.name}:`, geoError);
                        }
                    });
                    
                                            logMessage(`${service.name}: ✅ Loaded ${featureCount} features`, 'success');
                    return featureCount;
                    
                } catch (error) {
                    updateStatus(`${service.name}: ❌ ${error.message}`, 'error');
                    return 0;
                }
            }

            // Function to load comprehensive geographic data
            async function loadComprehensiveData() {
                logMessage('Loading comprehensive geographic data...', 'info');
                
                try {
                    // Load all US counties using a publicly accessible GeoJSON source
                    const countiesUrl = "https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json";
                    logMessage('Fetching US counties data from GeoJSON...', 'info');
                    
                    const countiesResponse = await fetch(countiesUrl);
                    
                    if (!countiesResponse.ok) {
                        throw new Error(`Counties HTTP ${countiesResponse.status}`);
                    }
                    
                    const countiesData = await countiesResponse.json();
                    logMessage(`Received counties data: ${countiesData.features ? countiesData.features.length : 0} features`, 'info');
                    
                    if (countiesData.features && countiesData.features.length > 0) {
                                            // Debug: Show the first county's attributes
                    if (countiesData.features.length > 0) {
                        logMessage(`First county attributes: ${JSON.stringify(countiesData.features[0].properties)}`, 'info');
                    }
                        
                        let countyCount = 0;
                        countiesData.features.forEach(feature => {
                            try {
                                if (feature.geometry && feature.geometry.coordinates) {
                                    // Convert GeoJSON coordinates to polygon rings
                                    const coordinates = feature.geometry.coordinates[0]; // First ring
                                    const rings = [coordinates];
                                    
                                    const polygon = new Polygon({
                                        rings: rings,
                                        spatialReference: { wkid: 4326 }
                                    });
                                    
                                    const graphic = new Graphic({
                                        geometry: polygon,
                                        symbol: new SimpleFillSymbol({
                                            color: [255, 255, 0, 0.05], // Very subtle yellow fill
                                            outline: new SimpleLineSymbol({
                                                color: [255, 255, 0, 0.15], // Very subtle yellow outline
                                                width: 0.5
                                            })
                                        }),
                                        attributes: {
                                            NAME: feature.properties.NAME || feature.properties.name,
                                            STATE_NAME: feature.properties.STATE || feature.properties.state,
                                            FIPS: feature.properties.FIPS || feature.properties.fips,
                                            layerType: "USGS",
                                            layerName: "US Counties",
                                            displayName: `${feature.properties.NAME || feature.properties.name}, ${feature.properties.STATE || feature.properties.state}`
                                        }
                                    });
                                    
                                    // Add to a separate layer for counties
                                    if (!countyLayer) {
                                        countyLayer = new GraphicsLayer({
                                            title: "US Counties",
                                            visible: true  // Visible by default
                                        });
                                        // Add county layer behind PSAP layers (at index 0)
                                        map.add(countyLayer, 0);
                                    }
                                    countyLayer.add(graphic);
                                    allGraphics.push(graphic);
                                    countyCount++;
                                }
                                                    } catch (geoError) {
                            logMessage(`County geometry error: ${geoError.message}`, 'error');
                        }
                        });
                        logMessage(`✅ Loaded ${countyCount} US counties`, 'success');
                        logMessage(`Added ${countyCount} counties to search database`, 'success');
                    } else {
                        logMessage('❌ No county features found in response', 'error');
                        logMessage(`Counties response: ${JSON.stringify(countiesData)}`, 'error');
                    }
                    
                    // Load all US states using a simple approach
                    const statesData = {
                        features: [
                            // Removed state boundaries - they're not very useful and cause visual clutter
                            // County boundaries are much more useful for search
                        ]
                    };
                    
                    logMessage(`Processing ${statesData.features.length} US states...`, 'info');
                    
                    let stateCount = 0;
                    statesData.features.forEach(feature => {
                        try {
                            if (feature.geometry && feature.geometry.coordinates) {
                                const coordinates = feature.geometry.coordinates[0];
                                const rings = [coordinates];
                                
                                const polygon = new Polygon({
                                    rings: rings,
                                    spatialReference: { wkid: 4326 }
                                });
                                
                                const graphic = new Graphic({
                                    geometry: polygon,
                                    symbol: new SimpleFillSymbol({
                                        color: [0, 255, 0, 0.05], // Very subtle green (almost invisible)
                                        outline: new SimpleLineSymbol({
                                            color: [0, 255, 0, 0.2], // Very subtle outline
                                            width: 1
                                        })
                                    }),
                                    attributes: {
                                        STATE_NAME: feature.properties.STATE_NAME,
                                        layerType: "USGS",
                                        layerName: "US States",
                                        displayName: feature.properties.STATE_NAME
                                    }
                                });
                                
                                if (!stateLayer) {
                                    stateLayer = new GraphicsLayer({
                                        title: "US States",
                                        visible: false  // Hidden by default
                                    });
                                    map.add(stateLayer);
                                }
                                stateLayer.add(graphic);
                                allGraphics.push(graphic);
                                stateCount++;
                            }
                        } catch (geoError) {
                            logMessage(`State geometry error: ${geoError.message}`, 'error');
                        }
                    });
                    logMessage(`✅ No state boundaries loaded (counties are more useful)`, 'success');
                    logMessage(`No states loaded - focusing on counties`, 'info');
                    
                    // Load Canadian Census Subdivisions
                    logMessage('Loading Canadian Census Subdivisions...', 'info');
                    await loadCanadianData();
                    
                    // Final debug check
                    const finalPSAPCount = allGraphics.filter(g => g.attributes.layerType === "PSAP").length;
                    const finalUSGSCount = allGraphics.filter(g => g.attributes.layerType === "USGS").length;
                    const finalCanadianCount = allGraphics.filter(g => g.attributes.layerType === "Canadian").length;
                    logMessage(`Final database after comprehensive load: ${allGraphics.length} total (${finalPSAPCount} PSAP, ${finalUSGSCount} USGS, ${finalCanadianCount} Canadian)`, 'success');
                    
                } catch (error) {
                    logMessage(`❌ Error loading comprehensive data: ${error.message}`, 'error');
                    logMessage(`Comprehensive data loading error: ${error.message}`, 'error');
                    
                    // Fallback: Try loading a simple test dataset
                    logMessage('Trying fallback data loading...', 'info');
                    await loadFallbackUSGSData();
                }
            }

            // Function to load Canadian Census Subdivisions with comprehensive pagination
            async function loadCanadianData() {
                try {
                    logMessage('Loading Canadian Census Subdivisions with comprehensive pagination...', 'info');
                    
                    // First, get the total count of features
                    const countUrl = `${canadianLayerConfig.url}/query?where=1%3D1&returnCountOnly=true&f=json`;
                    const countResponse = await fetch(countUrl);
                    
                    if (!countResponse.ok) {
                        throw new Error(`Canadian layer count query failed: ${countResponse.status}`);
                    }
                    
                    const countData = await countResponse.json();
                    const totalFeatures = countData.count || 0;
                    
                    logMessage(`Total Canadian features available: ${totalFeatures}`, 'info');
                    
                    if (totalFeatures === 0) {
                        logMessage('No Canadian features found in the layer', 'error');
                        return;
                    }
                    
                    // Create Canadian layer
                    if (!canadianLayer) {
                        canadianLayer = new GraphicsLayer({
                            title: "Canada Census Subdivisions",
                            visible: true
                        });
                        map.add(canadianLayer, 0);
                    }
                    
                    // Load data in batches using pagination
                    const batchSize = 1000;
                    const totalBatches = Math.ceil(totalFeatures / batchSize);
                    let totalLoaded = 0;
                    let totalErrors = 0;
                    
                    logMessage(`Loading ${totalFeatures} features in ${totalBatches} batches...`, 'info');
                    
                    for (let batch = 0; batch < totalBatches; batch++) {
                        try {
                            const offset = batch * batchSize;
                            const batchUrl = `${canadianLayerConfig.url}/query?where=1%3D1&outFields=CSDNAME,CSDTYPE,PRNAME,CDNAME&returnGeometry=true&f=json&resultRecordCount=${batchSize}&resultOffset=${offset}&orderByFields=CSDNAME&outSR=4326`;
                            
                            logMessage(`Loading batch ${batch + 1}/${totalBatches} (offset: ${offset})...`, 'info');
                            
                            const batchResponse = await fetch(batchUrl);
                            
                            if (!batchResponse.ok) {
                                logMessage(`Batch ${batch + 1} failed: ${batchResponse.status}`, 'warning');
                                continue;
                            }
                            
                            const batchData = await batchResponse.json();
                            
                            if (batchData.features && batchData.features.length > 0) {
                                let batchLoaded = 0;
                                let batchErrors = 0;
                                
                                batchData.features.forEach((feature, index) => {
                                    try {
                                        if (feature.geometry && feature.geometry.rings) {
                                            const rings = feature.geometry.rings;
                                            
                                            const polygon = new Polygon({
                                                rings: rings,
                                                spatialReference: { wkid: 4326 }
                                            });
                                            
                                            const graphic = new Graphic({
                                                geometry: polygon,
                                                symbol: new SimpleFillSymbol({
                                                    color: [0, 150, 255, 0.2],
                                                    outline: new SimpleLineSymbol({
                                                        color: [0, 150, 255, 0.8],
                                                        width: 1
                                                    })
                                                }),
                                                attributes: {
                                                    CSDNAME: feature.attributes.CSDNAME || 'Unknown',
                                                    CSDTYPE: feature.attributes.CSDTYPE || 'Unknown',
                                                    PRNAME: feature.attributes.PRNAME || 'Unknown',
                                                    CDNAME: feature.attributes.CDNAME || 'Unknown',
                                                    layerType: "Canadian",
                                                    layerName: "Canada Census Subdivisions",
                                                    displayName: `${feature.attributes.CSDNAME || 'Unknown'}, ${feature.attributes.PRNAME || 'Unknown'}`
                                                }
                                            });
                                            
                                            canadianLayer.add(graphic);
                                            allGraphics.push(graphic);
                                            batchLoaded++;
                                            totalLoaded++;
                                        }
                                    } catch (geoError) {
                                        batchErrors++;
                                        totalErrors++;
                                        if (totalErrors <= 10) { // Only log first 10 errors
                                            logMessage(`Geometry error in batch ${batch + 1}, feature ${index}: ${geoError.message}`, 'error');
                                        }
                                    }
                                });
                                
                                logMessage(`Batch ${batch + 1} loaded: ${batchLoaded} features (${batchErrors} errors)`, 'info');
                                
                                // Update progress
                                const progress = Math.round((totalLoaded / totalFeatures) * 100);
                                logMessage(`Progress: ${totalLoaded}/${totalFeatures} features loaded (${progress}%)`, 'info');
                                
                                // Small delay to prevent overwhelming the server
                                await new Promise(resolve => setTimeout(resolve, 100));
                                
                            } else {
                                logMessage(`Batch ${batch + 1} returned no features`, 'warning');
                            }
                            
                        } catch (batchError) {
                            logMessage(`Batch ${batch + 1} failed: ${batchError.message}`, 'warning');
                            totalErrors++;
                        }
                    }
                    
                    logMessage(`✅ Completed loading Canadian data: ${totalLoaded}/${totalFeatures} features loaded`, 'success');
                    if (totalErrors > 0) {
                        logMessage(`⚠️ ${totalErrors} features had errors and were skipped`, 'warning');
                    }
                    
                    // Try to get additional data with different query strategies
                    if (totalLoaded < totalFeatures * 0.9) { // If we got less than 90% of expected features
                        logMessage('Attempting to load additional Canadian data with alternative queries...', 'info');
                        await loadAdditionalCanadianData();
                    }
                    
                    // Auto-zoom to Canadian data if we have features
                    if (totalLoaded > 0) {
                        setTimeout(() => {
                            view.goTo(canadianLayer.graphics.toArray(), { padding: 50 });
                        }, 500);
                    }
                    
                } catch (error) {
                    logMessage(`❌ Error loading Canadian data: ${error.message}`, 'error');
                    // Fallback to test data if the real data fails
                    logMessage('Falling back to test Canadian data...', 'info');
                    await loadTestCanadianData();
                }
            }
            
            // Function to load additional Canadian data with different queries
            async function loadAdditionalCanadianData() {
                try {
                    logMessage('Loading additional Canadian data with targeted queries...', 'info');
                    
                    // Try different queries to get more comprehensive coverage
                    const additionalQueries = [
                        { where: "CSDTYPE='CY'", name: "Cities" },
                        { where: "CSDTYPE='T'", name: "Towns" },
                        { where: "CSDTYPE='M'", name: "Municipalities" },
                        { where: "CSDTYPE='RGM'", name: "Regional Municipalities" },
                        { where: "CSDTYPE='DM'", name: "Districts" },
                        { where: "CSDTYPE='CT'", name: "Census Subdivisions" },
                        { where: "CSDTYPE='IRI'", name: "Indian Reserves" },
                        { where: "CSDTYPE='NO'", name: "Northern Communities" },
                        { where: "CSDTYPE='SV'", name: "Specialized Villages" },
                        { where: "CSDTYPE='VL'", name: "Villages" },
                        { where: "CSDTYPE='TP'", name: "Townships" },
                        { where: "CSDTYPE='RM'", name: "Rural Municipalities" },
                        { where: "CSDTYPE='CR'", name: "Counties" },
                        { where: "CSDTYPE='RCR'", name: "Regional Counties" },
                        { where: "CSDTYPE='MD'", name: "Municipal Districts" },
                        { where: "CSDTYPE='SM'", name: "Specialized Municipalities" },
                        { where: "CSDTYPE='CU'", name: "Cantons" },
                        { where: "CSDTYPE='BOR'", name: "Boroughs" },
                        { where: "CSDTYPE='C'", name: "Cities (Alt)" },
                        { where: "CSDTYPE='TWP'", name: "Townships (Alt)" },
                        { where: "CSDTYPE='MUN'", name: "Municipalities (Alt)" },
                        { where: "CSDTYPE='PAR'", name: "Parishes" },
                        { where: "CSDTYPE='COM'", name: "Communities" },
                        { where: "CSDTYPE='SET'", name: "Settlements" },
                        { where: "CSDTYPE='HAM'", name: "Hamlets" },
                        { where: "CSDTYPE='N'", name: "Northern Communities (Alt)" },
                        { where: "CSDTYPE='UNO'", name: "Unorganized Areas" },
                        { where: "CSDTYPE='S-E'", name: "Specialized Areas" },
                        { where: "CSDTYPE='LGD'", name: "Local Government Districts" },
                        { where: "CSDTYPE='SNO'", name: "Subdivisions of Unorganized Areas" },
                        { where: "CSDTYPE='L'", name: "Localities" },
                        { where: "CSDTYPE='RDA'", name: "Regional Districts" },
                        { where: "CSDTYPE='R'", name: "Regions" }
                    ];
                    
                    let totalAdditional = 0;
                    let successfulQueries = 0;
                    
                    for (const query of additionalQueries) {
                        try {
                            const additionalUrl = `${canadianLayerConfig.url}/query?where=${encodeURIComponent(query.where)}&outFields=CSDNAME,CSDTYPE,PRNAME,CDNAME&returnGeometry=true&f=json&resultRecordCount=500&outSR=4326`;
                            const response = await fetch(additionalUrl);
                            
                            if (response.ok) {
                                const additionalData = await response.json();
                                
                                if (additionalData.features && additionalData.features.length > 0) {
                                    logMessage(`Loading ${additionalData.features.length} additional ${query.name} features...`, 'info');
                                    
                                    let additionalCount = 0;
                                    additionalData.features.forEach(feature => {
                                        try {
                                            if (feature.geometry && feature.geometry.rings) {
                                                const rings = feature.geometry.rings;
                                                
                                                const polygon = new Polygon({
                                                    rings: rings,
                                                    spatialReference: { wkid: 4326 }
                                                });
                                                
                                                const graphic = new Graphic({
                                                    geometry: polygon,
                                                    symbol: new SimpleFillSymbol({
                                                        color: [0, 150, 255, 0.2],
                                                        outline: new SimpleLineSymbol({
                                                            color: [0, 150, 255, 0.8],
                                                            width: 1
                                                        })
                                                    }),
                                                    attributes: {
                                                        CSDNAME: feature.attributes.CSDNAME || 'Unknown',
                                                        CSDTYPE: feature.attributes.CSDTYPE || 'Unknown',
                                                        PRNAME: feature.attributes.PRNAME || 'Unknown',
                                                        CDNAME: feature.attributes.CDNAME || 'Unknown',
                                                        layerType: "Canadian",
                                                        layerName: "Canada Census Subdivisions",
                                                        displayName: `${feature.attributes.CSDNAME || 'Unknown'}, ${feature.attributes.PRNAME || 'Unknown'}`
                                                    }
                                                });
                                                
                                                if (canadianLayer) {
                                                    canadianLayer.add(graphic);
                                                    allGraphics.push(graphic);
                                                    additionalCount++;
                                                    totalAdditional++;
                                                }
                                            }
                                        } catch (geoError) {
                                            // Skip errors for additional data
                                        }
                                    });
                                    
                                    logMessage(`Added ${additionalCount} additional ${query.name} features`, 'info');
                                    successfulQueries++;
                                }
                            }
                        } catch (error) {
                            // Continue with next query if one fails
                            logMessage(`Additional query failed for ${query.name}: ${error.message}`, 'warning');
                        }
                    }
                    
                    logMessage(`✅ Added ${totalAdditional} additional Canadian features from ${successfulQueries} successful queries`, 'success');
                    
                } catch (error) {
                    logMessage(`❌ Error loading additional Canadian data: ${error.message}`, 'error');
                }
            }

            // Fallback function for test Canadian data
            async function loadTestCanadianData() {
                try {
                    logMessage('Loading test Canadian data...', 'info');
                    
                    const testCanadianCities = [
                        { name: "Toronto", province: "Ontario", lat: 43.6532, lon: -79.3832 },
                        { name: "Vancouver", province: "British Columbia", lat: 49.2827, lon: -123.1207 },
                        { name: "Montreal", province: "Quebec", lat: 45.5017, lon: -73.5673 },
                        { name: "Calgary", province: "Alberta", lat: 51.0447, lon: -114.0719 },
                        { name: "Edmonton", province: "Alberta", lat: 53.5461, lon: -113.4938 },
                        { name: "Ottawa", province: "Ontario", lat: 45.4215, lon: -75.6972 },
                        { name: "Winnipeg", province: "Manitoba", lat: 49.8951, lon: -97.1384 },
                        { name: "Quebec City", province: "Quebec", lat: 46.8139, lon: -71.2080 },
                        { name: "Hamilton", province: "Ontario", lat: 43.2557, lon: -79.8711 },
                        { name: "Kitchener", province: "Ontario", lat: 43.4516, lon: -80.4925 }
                    ];
                    
                    let canadianCount = 0;
                    testCanadianCities.forEach(city => {
                        try {
                            const rings = [[
                                [city.lon - 0.05, city.lat - 0.05],
                                [city.lon + 0.05, city.lat - 0.05],
                                [city.lon + 0.05, city.lat + 0.05],
                                [city.lon - 0.05, city.lat + 0.05],
                                [city.lon - 0.05, city.lat - 0.05]
                            ]];
                            
                            const polygon = new Polygon({
                                rings: rings,
                                spatialReference: { wkid: 4326 }
                            });
                            
                            const graphic = new Graphic({
                                geometry: polygon,
                                symbol: new SimpleFillSymbol({
                                    color: [0, 150, 255, 0.3],
                                    outline: new SimpleLineSymbol({
                                        color: [0, 150, 255, 1.0],
                                        width: 2
                                    })
                                }),
                                attributes: {
                                    CSDNAME: city.name,
                                    CSDTYPE: "City",
                                    PRNAME: city.province,
                                    CDNAME: city.province,
                                    layerType: "Canadian",
                                    layerName: "Canada Test Cities",
                                    displayName: `${city.name}, ${city.province}`
                                }
                            });
                            
                            if (!canadianLayer) {
                                canadianLayer = new GraphicsLayer({
                                    title: "Canada Test Cities",
                                    visible: true
                                });
                                map.add(canadianLayer, 0);
                            }
                            canadianLayer.add(graphic);
                            allGraphics.push(graphic);
                            canadianCount++;
                            
                        } catch (geoError) {
                            logMessage(`Test Canadian geometry error: ${geoError.message}`, 'error');
                        }
                    });
                    
                    logMessage(`✅ Loaded ${canadianCount} test Canadian cities`, 'success');
                    
                    if (canadianCount > 0) {
                        setTimeout(() => {
                            view.goTo(canadianLayer.graphics.toArray(), { padding: 50 });
                        }, 500);
                    }
                    
                } catch (error) {
                    logMessage(`❌ Error loading test Canadian data: ${error.message}`, 'error');
                }
            }

            // Fallback function to load USGS data using a different approach
            async function loadFallbackUSGSData() {
                try {
                    logMessage('Loading fallback USGS data...', 'info');
                    
                    // Create some test county data manually
                    const testCounties = [
                        { name: "Monmouth", state: "New Jersey", lat: 40.28, lon: -74.15 },
                        { name: "Monmouth", state: "Illinois", lat: 40.91, lon: -90.64 },
                        { name: "Essex", state: "New Jersey", lat: 40.79, lon: -74.25 },
                        { name: "Bergen", state: "New Jersey", lat: 40.96, lon: -74.07 }
                    ];
                    
                    let countyCount = 0;
                    testCounties.forEach(county => {
                        try {
                            // Create a simple polygon for the county (approximate)
                            const rings = [[
                                [county.lon - 0.1, county.lat - 0.1],
                                [county.lon + 0.1, county.lat - 0.1],
                                [county.lon + 0.1, county.lat + 0.1],
                                [county.lon - 0.1, county.lat + 0.1],
                                [county.lon - 0.1, county.lat - 0.1]
                            ]];
                            
                            const polygon = new Polygon({
                                rings: rings,
                                spatialReference: { wkid: 4326 }
                            });
                            
                            const graphic = new Graphic({
                                geometry: polygon,
                                symbol: new SimpleFillSymbol({
                                    color: [255, 255, 0, 0.05], // Very subtle yellow fill
                                    outline: new SimpleLineSymbol({
                                        color: [255, 255, 0, 0.15], // Very subtle yellow outline
                                        width: 0.5
                                    })
                                }),
                                attributes: {
                                    NAME: county.name,
                                    STATE_NAME: county.state,
                                    layerType: "USGS",
                                    layerName: "Test Counties",
                                    displayName: `${county.name}, ${county.state}`
                                }
                            });
                            
                            if (!countyLayer) {
                                countyLayer = new GraphicsLayer({
                                    title: "Test Counties",
                                    visible: false  // Hidden by default
                                });
                                // Add county layer behind PSAP layers (at index 0)
                                map.add(countyLayer, 0);
                            }
                            countyLayer.add(graphic);
                            allGraphics.push(graphic);
                            countyCount++;
                            
                        } catch (geoError) {
                            logMessage(`Test county geometry error: ${geoError.message}`, 'error');
                        }
                    });
                    
                                            logMessage(`✅ Loaded ${countyCount} test counties as fallback`, 'success');
                        logMessage(`Added ${countyCount} test counties to search database`, 'success');
                    
                } catch (error) {
                    logMessage(`❌ Fallback loading also failed: ${error.message}`, 'error');
                    logMessage(`Fallback loading error: ${error.message}`, 'error');
                }
            }

            // Function to load all PSAP data in parallel
            async function loadPSAPData() {
                clearMap();
                updateStatus('Starting to load PSAP services in parallel...', 'info');
                
                const startTime = Date.now();
                
                // Load PSAP services in parallel
                const psapPromises = workingServices.map(service => loadService(service));
                const psapResults = await Promise.allSettled(psapPromises);
                
                let totalFeatures = 0;
                psapResults.forEach((result, index) => {
                    if (result.status === 'fulfilled') {
                        totalFeatures += result.value;
                    } else {
                        updateStatus(`${workingServices[index].name}: ❌ Failed to load`, 'error');
                    }
                });
                
                const loadTime = Date.now() - startTime;
                updateStatus(`🎉 PSAP Complete! Loaded ${totalFeatures} features in ${loadTime}ms`, 'success');
                
                // Load comprehensive geographic data
                await loadComprehensiveData();
                
                // Auto-zoom to data if we have features
                if (totalFeatures > 0) {
                    setTimeout(() => {
                        view.goTo(psapLayer.graphics.toArray(), { padding: 50 });
                    }, 500);
                }
                
                // Show final status
                const psapCount = allGraphics.filter(g => g.attributes.layerType === "PSAP").length;
                const usgsCount = allGraphics.filter(g => g.attributes.layerType === "USGS").length;
                updateStatus(`📊 Final Database: ${allGraphics.length} total features (${psapCount} PSAP, ${usgsCount} USGS) - PSAP data loads automatically when you zoom to an area`, 'success');
            }

            // Function to clear the map
            function clearMap() {
                psapLayer.removeAll();
                if (countyLayer) countyLayer.removeAll();
                if (stateLayer) stateLayer.removeAll();
                if (canadianLayer) canadianLayer.removeAll();
                allGraphics = [];
                closePopup();
                clearSearch();
                updateStatus('Map cleared', 'info');
            }

            // Function to zoom to US
            function zoomToUS() {
                view.goTo({ center: [-98.5795, 39.8283], zoom: 4 });
                updateStatus('Zoomed to US', 'info');
            }

            // Function to update status (hidden from user, only logged)
            function updateStatus(message, type = 'info') {
                // Only log the message, don't show to user interface
                logMessage(message, type);
            }

            // Add search input event listener
            document.getElementById('searchInput').addEventListener('input', function(e) {
                searchGraphics(e.target.value);
            });
            
            // Add keyboard shortcut for debug tools
            document.addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.key === 'd') {
                    e.preventDefault();
                    const debugTools = document.querySelector('.debug-tools');
                    if (debugTools) {
                        debugTools.style.display = debugTools.style.display === 'none' ? 'block' : 'none';
                    }
                }
            });

            // Add automatic boundary loading when map view changes
            let boundaryLoadTimeout;
            view.watch("extent", function(newExtent) {
                // Don't auto-load if search is active
                if (searchActive) {
                    return;
                }
                
                // Don't auto-load if there are already visible graphics (from search results)
                const hasVisibleGraphics = (psapLayer && psapLayer.graphics.length > 0) || 
                                         (countyLayer && countyLayer.graphics.length > 0) ||
                                         (canadianLayer && canadianLayer.graphics.length > 0);
                
                if (hasVisibleGraphics) {
                    logMessage('Skipping auto-load - graphics already visible from search results', 'info');
                    return;
                }
                
                // Clear previous timeout
                if (boundaryLoadTimeout) {
                    clearTimeout(boundaryLoadTimeout);
                }
                
                // Set a new timeout to load boundaries after user stops moving
                boundaryLoadTimeout = setTimeout(() => {
                    // Only auto-load if zoom level is appropriate (not too zoomed out)
                    if (view.zoom > 6) {
                        showBoundariesForCurrentView();
                    }
                }, 1500); // Wait 1.5 seconds after user stops moving
            });

            // Add click event handler
            view.on("click", function(event) {
                // Don't process clicks on UI elements
                if (event.target && (event.target.closest('#info') || event.target.closest('.popup'))) {
                    return;
                }
                
                // Close any existing popup
                closePopup();
                
                // Get the screen point
                const screenPoint = {
                    x: event.x,
                    y: event.y
                };
                
                // Query for graphics at the click location
                view.hitTest(screenPoint).then(function(response) {
                    if (response.results.length > 0) {
                        const graphic = response.results[0].graphic;
                        if (graphic && graphic.attributes) {
                            // Check if it's any selectable feature (PSAP, USGS, Canadian, or any other layer)
                            if (graphic.attributes.state || graphic.attributes.layerType || graphic.attributes.NAME || graphic.attributes.CSDNAME) {
                                if (isSelectionMode) {
                                    // In selection mode, select/deselect the graphic
                                    selectGraphic(graphic);
                                } else {
                                    // Normal mode, show popup
                                    showLayerForGraphic(graphic);
                                    showFeaturePopup(graphic, screenPoint);
                                }
                            }
                        }
                    }
                });
            });

            // Close popup when clicking outside
            view.on("click", function(event) {
                const popup = document.getElementById('featurePopup');
                if (popup.style.display === 'block') {
                    const popupRect = popup.getBoundingClientRect();
                    const clickX = event.x;
                    const clickY = event.y;
                    
                    if (clickX < popupRect.left || clickX > popupRect.right || 
                        clickY < popupRect.top || clickY > popupRect.bottom) {
                        closePopup();
                    }
                }
            });

            // Variable to track current USGS layer
            let currentUSGSLayer = null;

            // Function to toggle USGS layer
            function toggleUSGSLayer() {
                const select = document.getElementById('usgsLayerSelect');
                const selectedValue = select.value;
                
                // Remove current layer if exists
                if (currentUSGSLayer) {
                    map.remove(currentUSGSLayer);
                    // Remove USGS features from search database
                    allGraphics = allGraphics.filter(graphic => graphic.attributes.layerType !== "USGS");
                    currentUSGSLayer = null;
                    updateStatus('Removed USGS reference layer and cleared from search', 'info');
                }
                
                // Add new layer if selected
                if (selectedValue) {
                    const layerUrl = `https://carto.nationalmap.gov/arcgis/rest/services/govunits/mapserver/${selectedValue}`;
                    const layerName = select.options[select.selectedIndex].text;
                    
                    currentUSGSLayer = new FeatureLayer({
                        url: layerUrl,
                        title: `USGS ${layerName}`,
                        opacity: 0.6,
                        visible: true,
                        popupTemplate: {
                            title: `{*}`,
                            content: [
                                {
                                    type: "fields",
                                    fieldInfos: [
                                        { fieldName: "NAME", label: "Name" },
                                        { fieldName: "STATE_NAME", label: "State" },
                                        { fieldName: "COUNTY_NAME", label: "County" },
                                        { fieldName: "FCODE", label: "Feature Code" },
                                        { fieldName: "AREASQKM", label: "Area (sq km)" },
                                        { fieldName: "POPULATION", label: "Population" }
                                    ]
                                }
                            ]
                        }
                    });
                    
                    // Add click event to load features into search
                    currentUSGSLayer.when(() => {
                        loadUSGSFeaturesToSearch(currentUSGSLayer, layerName);
                    });
                    
                    // Add USGS layer behind PSAP layers (at index 0 to put it behind everything)
                    map.add(currentUSGSLayer, 0);
                    updateStatus(`Added USGS layer: ${layerName}`, 'success');
                }
            }

            // Function to load USGS features into searchable graphics
            async function loadUSGSFeaturesToSearch(layer, layerName) {
                try {
                    const query = layer.createQuery();
                    query.where = "1=1";
                    query.outFields = ["*"];
                    query.returnGeometry = true;
                    query.maxRecordCount = 1000;
                    
                    const results = await layer.queryFeatures(query);
                    
                    if (results.features && results.features.length > 0) {
                        results.features.forEach(feature => {
                            // Create a searchable graphic from the feature
                            const searchableGraphic = {
                                attributes: {
                                    ...feature.attributes,
                                    layerType: "USGS",
                                    layerName: layerName,
                                    displayName: getUSGSDisplayName(feature.attributes, layerName)
                                },
                                geometry: feature.geometry,
                                source: "USGS"
                            };
                            
                            allGraphics.push(searchableGraphic);
                        });
                        
                        updateStatus(`Loaded ${results.features.length} ${layerName} features for search`, 'success');
                    }
                } catch (error) {
                    console.error('Error loading USGS features for search:', error);
                    updateStatus(`Error loading ${layerName} features for search`, 'error');
                }
            }

            // Function to get display name for USGS features
            function getUSGSDisplayName(attributes, layerName) {
                if (attributes.NAME) return attributes.NAME;
                if (attributes.STATE_NAME) return attributes.STATE_NAME;
                if (attributes.COUNTY_NAME) return attributes.COUNTY_NAME;
                if (attributes.GNIS_NAME) return attributes.GNIS_NAME;
                return `${layerName} Feature`;
            }

            // Function to show search database status
            function showSearchStatus() {
                const psapCount = allGraphics.filter(g => g.attributes.layerType === "PSAP").length;
                const usgsCount = allGraphics.filter(g => g.attributes.layerType === "USGS").length;
                const totalCount = allGraphics.length;
                
                updateStatus(`Search Database: ${totalCount} total features (${psapCount} PSAP, ${usgsCount} USGS)`, 'info');
                
                // Show breakdown of USGS features by layer
                if (usgsCount > 0) {
                    const usgsLayers = {};
                    allGraphics.filter(g => g.attributes.layerType === "USGS").forEach(g => {
                        const layerName = g.attributes.layerName;
                        usgsLayers[layerName] = (usgsLayers[layerName] || 0) + 1;
                    });
                    
                    Object.keys(usgsLayers).forEach(layerName => {
                        updateStatus(`  - ${layerName}: ${usgsLayers[layerName]} features`, 'info');
                    });
                }
                
                // Debug: Show some sample USGS features
                if (usgsCount > 0) {
                    const sampleUSGS = allGraphics.filter(g => g.attributes.layerType === "USGS").slice(0, 3);
                    sampleUSGS.forEach((g, i) => {
                        updateStatus(`  Sample ${i+1}: ${g.attributes.displayName || g.attributes.NAME || 'Unknown'}`, 'info');
                    });
                }
            }

            // Function to test search with specific county
            function testCountySearch() {
                const testCounty = "Monmouth";
                updateStatus(`Testing search for "${testCounty}"...`, 'info');
                
                // Find all graphics that contain this county name
                const matches = allGraphics.filter(g => {
                    const attrs = g.attributes;
                    return Object.values(attrs).some(value => 
                        value && String(value).toLowerCase().includes(testCounty.toLowerCase())
                    );
                });
                
                updateStatus(`Found ${matches.length} matches for "${testCounty}":`, 'info');
                matches.forEach((match, i) => {
                    const layerType = match.attributes.layerType;
                    const name = match.attributes.displayName || match.attributes.NAME || 'Unknown';
                    updateStatus(`  ${i+1}. ${layerType}: ${name}`, 'info');
                });
                
                // Also test the actual search function
                searchGraphics(testCounty);
            }

            // Function to refresh search database
            function refreshSearchDatabase() {
                updateStatus('Refreshing search database...', 'info');
                
                // Clear current search database
                allGraphics = [];
                
                // Re-add all PSAP graphics from the layer
                psapLayer.graphics.forEach(graphic => {
                    allGraphics.push(graphic);
                });
                
                // Re-add all USGS graphics from loaded layers
                map.layers.forEach(layer => {
                    if (layer.title && layer.title.includes('USGS')) {
                        // This is a USGS layer, try to get its features
                        if (layer.graphics) {
                            layer.graphics.forEach(graphic => {
                                allGraphics.push(graphic);
                            });
                        }
                    }
                });
                
                const psapCount = allGraphics.filter(g => g.attributes.layerType === "PSAP").length;
                const usgsCount = allGraphics.filter(g => g.attributes.layerType === "USGS").length;
                const totalCount = allGraphics.length;
                
                updateStatus(`Search database refreshed: ${totalCount} total features (${psapCount} PSAP, ${usgsCount} USGS)`, 'success');
            }

            // Function to toggle county layer visibility
            function toggleCountyLayer() {
                if (countyLayer) {
                    countyLayer.visible = !countyLayer.visible;
                    updateStatus(`Counties ${countyLayer.visible ? 'shown' : 'hidden'}`, 'info');
                } else {
                    updateStatus('County layer not loaded yet', 'error');
                }
            }

            // Function to toggle state layer visibility
            function toggleStateLayer() {
                if (stateLayer) {
                    stateLayer.visible = !stateLayer.visible;
                    updateStatus(`States ${stateLayer.visible ? 'shown' : 'hidden'}`, 'info');
                } else {
                    updateStatus('State layer not loaded yet', 'error');
                }
            }

            // Function to show relevant layers based on search results
            function showRelevantLayers(results) {
                logMessage(`showRelevantLayers called with ${results.length} results`, 'info');
                const hasPSAP = results.some(r => r.graphic.attributes.layerType === "PSAP");
                const hasCounties = results.some(r => r.graphic.attributes.layerType === "USGS" && r.graphic.attributes.layerName === "US Counties");
                const hasStates = results.some(r => r.graphic.attributes.layerType === "USGS" && r.graphic.attributes.layerName === "US States");
                
                logMessage(`Layer detection: ${JSON.stringify({ hasPSAP, hasCounties, hasStates })}`, 'info');
                
                // Show PSAP layer if PSAP results found
                if (hasPSAP) {
                    psapLayer.visible = true;
                    logMessage(`PSAP layer visibility set to: ${psapLayer.visible}`, 'info');
                    updateStatus('PSAP layer shown for search results', 'info');
                }
                
                // Show county layer if county results found
                if (hasCounties && countyLayer) {
                    countyLayer.visible = true;
                    logMessage(`County layer visibility set to: ${countyLayer.visible}`, 'info');
                    updateStatus('County layer shown for search results', 'info');
                } else if (hasCounties && !countyLayer) {
                    logMessage('County results found but countyLayer is null!', 'error');
                    updateStatus('County layer not available', 'error');
                }
                
                // Show state layer if state results found
                if (hasStates && stateLayer) {
                    stateLayer.visible = true;
                    updateStatus('State layer shown for search results', 'info');
                }
                
                // If no specific layer types found, show all layers
                if (!hasPSAP && !hasCounties && !hasStates) {
                    psapLayer.visible = true;
                    if (countyLayer) countyLayer.visible = true;
                    if (stateLayer) stateLayer.visible = true;
                    updateStatus('All layers shown for search results', 'info');
                }
            }

            // Function to hide all layers
            function hideAllLayers() {
                psapLayer.visible = false;
                if (countyLayer) countyLayer.visible = false;
                if (stateLayer) stateLayer.visible = false;
                updateStatus('All layers hidden - no search results', 'info');
            }

            // Function to show all layers
            function showAllLayers() {
                psapLayer.visible = true;
                if (countyLayer) countyLayer.visible = true;
                if (stateLayer) stateLayer.visible = true;
                updateStatus('All layers shown', 'info');
            }

            // Function to debug layer status
            function debugLayerStatus() {
                logMessage('=== LAYER STATUS DEBUG ===', 'info');
                logMessage(`PSAP Layer exists: ${!!psapLayer}`, 'info');
                logMessage(`PSAP Layer visible: ${psapLayer ? psapLayer.visible : 'N/A'}`, 'info');
                logMessage(`County Layer exists: ${!!countyLayer}`, 'info');
                logMessage(`County Layer visible: ${countyLayer ? countyLayer.visible : 'N/A'}`, 'info');
                logMessage(`State Layer exists: ${!!stateLayer}`, 'info');
                logMessage(`State Layer visible: ${stateLayer ? stateLayer.visible : 'N/A'}`, 'info');
                logMessage(`Total graphics in database: ${allGraphics.length}`, 'info');
                logMessage(`PSAP graphics: ${allGraphics.filter(g => g.attributes.layerType === "PSAP").length}`, 'info');
                logMessage(`USGS graphics: ${allGraphics.filter(g => g.attributes.layerType === "USGS").length}`, 'info');
                logMessage('========================', 'info');
                
                updateStatus('Layer status logged - click "View Logs" to see details', 'info');
            }

            // Function to show boundaries for current map view
            function showBoundariesForCurrentView() {
                logMessage('Loading boundaries for current view...', 'info');
                
                // Get the current map extent
                const extent = view.extent;
                logMessage(`Current map extent: ${JSON.stringify(extent)}`, 'info');
                
                // Only clear existing graphics if they're not from search results
                // (This prevents clearing search results when auto-loading boundaries)
                if (!searchActive) {
                    psapLayer.removeAll();
                    if (countyLayer) countyLayer.removeAll();
                }
                
                // Find all graphics within the current extent
                const visibleGraphics = allGraphics.filter(graphic => {
                    if (graphic.geometry) {
                        return extent.contains(graphic.geometry);
                    }
                    return false;
                });
                
                logMessage(`Found ${visibleGraphics.length} features in current view`, 'info');
                
                // Group by layer type
                const psapFeatures = visibleGraphics.filter(g => g.attributes.state); // PSAP features have 'state' attribute
                const countyFeatures = visibleGraphics.filter(g => g.attributes.layerType === "USGS" && g.attributes.layerName === "US Counties");
                
                // Always try to show PSAP features first
                if (psapFeatures.length > 0) {
                    psapFeatures.forEach(graphic => {
                        psapLayer.add(graphic);
                    });
                    psapLayer.visible = true;
                    logMessage(`✅ Showing ${psapFeatures.length} PSAP boundaries for current area`, 'success');
                    
                    // Also show county boundaries for context
                    if (countyFeatures.length > 0) {
                        if (!countyLayer) {
                            countyLayer = new GraphicsLayer({
                                title: "US Counties",
                                visible: true  // Visible by default
                            });
                            // Add county layer behind PSAP layers (at index 0)
                            map.add(countyLayer, 0);
                        }
                        
                        countyFeatures.forEach(graphic => {
                            countyLayer.add(graphic);
                        });
                        logMessage(`✅ Also showing ${countyFeatures.length} county boundaries for context`, 'success');
                    }
                } else {
                    // No PSAP data in this area - guide user to search USGS layers
                    logMessage('❌ No PSAP data found in this area', 'error');
                    logMessage('💡 Try searching for specific locations using the search box above', 'info');
                    logMessage('💡 Or select a USGS layer from the dropdown to see county/state boundaries', 'info');
                    
                    // Optionally show county boundaries anyway for reference
                    if (countyFeatures.length > 0) {
                        if (!countyLayer) {
                            countyLayer = new GraphicsLayer({
                                title: "US Counties",
                                visible: true  // Visible by default
                            });
                            // Add county layer behind PSAP layers (at index 0)
                            map.add(countyLayer, 0);
                        }
                        
                        countyFeatures.forEach(graphic => {
                            countyLayer.add(graphic);
                        });
                        logMessage(`✅ Showing ${countyFeatures.length} county boundaries for reference`, 'info');
                    }
                }
            }

            // Function to clear all boundaries
            function clearAllBoundaries() {
                psapLayer.removeAll();
                if (countyLayer) countyLayer.removeAll();
                psapLayer.visible = false;
                if (countyLayer) countyLayer.visible = false;
                updateStatus('All boundaries cleared', 'info');
            }

            // Function to toggle selection mode
            function toggleSelectionMode() {
                isSelectionMode = !isSelectionMode;
                const button = document.querySelector('button[onclick="toggleSelectionMode()"]');
                if (button) {
                    button.textContent = isSelectionMode ? 'Exit Selection Mode' : 'Selection Mode';
                    button.style.backgroundColor = isSelectionMode ? '#FF6B6B' : '';
                    button.className = isSelectionMode ? 'btn-secondary active' : 'btn-secondary';
                }
                
                // Ensure layers stay visible when entering selection mode
                if (isSelectionMode) {
                    if (psapLayer) psapLayer.visible = true;
                    if (countyLayer) countyLayer.visible = true;
                    if (canadianLayer) canadianLayer.visible = true;
                    logMessage('Ensured all layers are visible for selection mode', 'info');
                }
                
                // Show available layers for selection
                if (isSelectionMode) {
                    const availableLayers = [];
                    
                    // Debug: Log what's in allGraphics
                    logMessage(`Total graphics in allGraphics: ${allGraphics.length}`, 'info');
                    
                    // Check for different attribute patterns
                    const psapCount = allGraphics.filter(g => g.attributes && g.attributes.state).length;
                    const usgsCount = allGraphics.filter(g => g.attributes && (g.attributes.layerType === "USGS" || g.attributes.NAME)).length;
                    const canadianCount = allGraphics.filter(g => g.attributes && (g.attributes.layerType === "Canadian" || g.attributes.CSDNAME)).length;
                    
                    // Debug: Log individual counts
                    logMessage(`PSAP count (state attribute): ${psapCount}`, 'info');
                    logMessage(`USGS count (layerType=USGS or NAME attribute): ${usgsCount}`, 'info');
                    logMessage(`Canadian count (layerType=Canadian or CSDNAME attribute): ${canadianCount}`, 'info');
                    
                    // Debug: Log sample attributes
                    if (allGraphics.length > 0) {
                        const sampleGraphic = allGraphics[0];
                        logMessage(`Sample graphic attributes: ${JSON.stringify(sampleGraphic.attributes)}`, 'info');
                    }
                    
                    if (psapCount > 0) availableLayers.push(`${psapCount} PSAP boundaries`);
                    if (usgsCount > 0) availableLayers.push(`${usgsCount} USGS boundaries`);
                    if (canadianCount > 0) availableLayers.push(`${canadianCount} Canadian boundaries`);
                    
                    const layerInfo = availableLayers.length > 0 ? 
                        `Available for selection: ${availableLayers.join(', ')}` : 
                        'No boundaries available for selection';
                    
                    updateStatus(`Selection mode enabled. ${layerInfo}`, 'info');
                } else {
                    updateStatus('Selection mode disabled', 'info');
                }
            }

            // Function to select a graphic
            function selectGraphic(graphic) {
                if (!isSelectionMode) return;
                
                // Check if already selected
                const isSelected = selectedGraphics.some(g => g === graphic);
                
                if (isSelected) {
                    // Deselect
                    selectedGraphics = selectedGraphics.filter(g => g !== graphic);
                    // Reset symbol to original based on layer type
                    if (graphic.attributes.state) {
                        // PSAP features have 'state' attribute
                        graphic.symbol = new SimpleFillSymbol({
                            color: [255, 0, 0, 0.3],
                            outline: new SimpleLineSymbol({
                                color: [255, 0, 0, 0.8],
                                width: 2
                            })
                        });
                    } else if (graphic.attributes.layerType === "USGS") {
                        graphic.symbol = new SimpleFillSymbol({
                            color: [255, 255, 0, 0.05], // Very subtle yellow fill
                            outline: new SimpleLineSymbol({
                                color: [255, 255, 0, 0.15], // Very subtle yellow outline
                                width: 0.5
                            })
                        });
                    } else if (graphic.attributes.layerType === "Canadian") {
                        graphic.symbol = new SimpleFillSymbol({
                            color: [0, 150, 255, 0.05], // Very subtle blue fill
                            outline: new SimpleLineSymbol({
                                color: [0, 150, 255, 0.15], // Very subtle blue outline
                                width: 0.5
                            })
                        });
                    } else {
                        // Default fallback for any other layer type
                        graphic.symbol = new SimpleFillSymbol({
                            color: [128, 128, 128, 0.3],
                            outline: new SimpleLineSymbol({
                                color: [128, 128, 128, 0.8],
                                width: 1
                            })
                        });
                    }
                } else {
                    // Select
                    selectedGraphics.push(graphic);
                    // Highlight with selection symbol
                    graphic.symbol = new SimpleFillSymbol({
                        color: [0, 255, 0, 0.5], // Green for selected
                        outline: new SimpleLineSymbol({
                            color: [0, 255, 0, 1],
                            width: 3
                        })
                    });
                }
                
                // Determine layer type and name
                let layerType = 'Unknown';
                if (graphic.attributes.state) {
                    layerType = 'PSAP';
                } else if (graphic.attributes.layerType) {
                    layerType = graphic.attributes.layerType;
                } else if (graphic.attributes.NAME) {
                    layerType = 'USGS';
                } else if (graphic.attributes.CSDNAME) {
                    layerType = 'Canadian';
                }
                
                const name = graphic.attributes.displayName || graphic.attributes.NAME || graphic.attributes.CSDNAME || 'Unknown';
                const action = isSelected ? 'deselected' : 'selected';
                updateStatus(`${action} ${layerType} boundary: ${name} (${selectedGraphics.length} total selected)`, 'info');
            }

            // Function to show selection summary
            function showSelectionSummary() {
                if (selectedGraphics.length === 0) {
                    updateStatus('No features currently selected', 'info');
                    return;
                }
                
                // Count features by layer type
                const layerCounts = {};
                const layerDetails = {};
                
                selectedGraphics.forEach(graphic => {
                    let layerType = 'Unknown';
                    let name = 'Unknown';
                    
                    if (graphic.attributes.state) {
                        layerType = 'PSAP';
                        name = graphic.attributes.displayName || graphic.attributes.name || graphic.attributes.state;
                    } else if (graphic.attributes.layerType === "USGS") {
                        layerType = 'USGS';
                        name = graphic.attributes.displayName || graphic.attributes.NAME || 'USGS Feature';
                    } else if (graphic.attributes.layerType === "Canadian") {
                        layerType = 'Canadian';
                        name = graphic.attributes.displayName || graphic.attributes.CSDNAME || 'Canadian Feature';
                    } else if (graphic.attributes.NAME) {
                        layerType = 'USGS';
                        name = graphic.attributes.NAME;
                    } else if (graphic.attributes.CSDNAME) {
                        layerType = 'Canadian';
                        name = graphic.attributes.CSDNAME;
                    }
                    
                    layerCounts[layerType] = (layerCounts[layerType] || 0) + 1;
                    
                    if (!layerDetails[layerType]) {
                        layerDetails[layerType] = [];
                    }
                    layerDetails[layerType].push(name);
                });
                
                // Create summary message
                const summary = Object.entries(layerCounts)
                    .map(([type, count]) => `${count} ${type} features`)
                    .join(', ');
                
                updateStatus(`Selected: ${summary}`, 'success');
                
                // Log detailed breakdown
                logMessage(`=== SELECTION SUMMARY ===`, 'info');
                logMessage(`Total selected: ${selectedGraphics.length} features`, 'info');
                
                Object.entries(layerDetails).forEach(([type, names]) => {
                    logMessage(`${type} (${names.length}): ${names.slice(0, 5).join(', ')}${names.length > 5 ? '...' : ''}`, 'info');
                });
                logMessage(`========================`, 'info');
            }

            // Function to clear selection
            function clearSelection() {
                // Reset symbols for all selected graphics
                selectedGraphics.forEach(graphic => {
                    if (graphic.attributes.state) {
                        // PSAP features have 'state' attribute
                        graphic.symbol = new SimpleFillSymbol({
                            color: [255, 0, 0, 0.3],
                            outline: new SimpleLineSymbol({
                                color: [255, 0, 0, 0.8],
                                width: 2
                            })
                        });
                    } else if (graphic.attributes.layerType === "USGS") {
                        graphic.symbol = new SimpleFillSymbol({
                            color: [255, 255, 0, 0.05], // Very subtle yellow fill
                            outline: new SimpleLineSymbol({
                                color: [255, 255, 0, 0.15], // Very subtle yellow outline
                                width: 0.5
                            })
                        });
                    } else if (graphic.attributes.layerType === "Canadian") {
                        graphic.symbol = new SimpleFillSymbol({
                            color: [0, 150, 255, 0.05], // Very subtle blue fill
                            outline: new SimpleLineSymbol({
                                color: [0, 150, 255, 0.15], // Very subtle blue outline
                                width: 0.5
                            })
                        });
                    } else {
                        // Default fallback for any other layer type
                        graphic.symbol = new SimpleFillSymbol({
                            color: [128, 128, 128, 0.3],
                            outline: new SimpleLineSymbol({
                                color: [128, 128, 128, 0.8],
                                width: 1
                            })
                        });
                    }
                });
                
                selectedGraphics = [];
                updateStatus('Selection cleared', 'info');
            }

            // Function to download selected features
            function downloadSelected() {
                if (selectedGraphics.length === 0) {
                    updateStatus('No features selected for download', 'error');
                    return;
                }
                
                // Count features by layer type
                const layerCounts = {};
                selectedGraphics.forEach(graphic => {
                    let layerType = 'Unknown';
                    if (graphic.attributes.state) {
                        layerType = 'PSAP';
                    } else if (graphic.attributes.layerType) {
                        layerType = graphic.attributes.layerType;
                    } else if (graphic.attributes.NAME) {
                        layerType = 'USGS';
                    } else if (graphic.attributes.CSDNAME) {
                        layerType = 'Canadian';
                    }
                    
                    layerCounts[layerType] = (layerCounts[layerType] || 0) + 1;
                });
                
                // Convert selected graphics to GeoJSON
                const geojson = {
                    type: "FeatureCollection",
                    features: selectedGraphics.map(graphic => {
                        // Determine layer type for properties
                        let layerType = 'Unknown';
                        if (graphic.attributes.state) {
                            layerType = 'PSAP';
                        } else if (graphic.attributes.layerType) {
                            layerType = graphic.attributes.layerType;
                        } else if (graphic.attributes.NAME) {
                            layerType = 'USGS';
                        } else if (graphic.attributes.CSDNAME) {
                            layerType = 'Canadian';
                        }
                        
                        const feature = {
                            type: "Feature",
                            properties: {
                                ...graphic.attributes,
                                layerType: layerType,
                                layerName: graphic.attributes.layerName || graphic.attributes.displayName || 'Unknown Layer',
                                downloadDate: new Date().toISOString(),
                                downloadSource: 'PSAP Multi-Select Map'
                            },
                            geometry: {
                                type: "Polygon",
                                coordinates: graphic.geometry.rings
                            }
                        };
                        return feature;
                    })
                };
                
                // Create download link
                const dataStr = JSON.stringify(geojson, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                
                // Create descriptive filename
                const layerTypes = Object.keys(layerCounts).join('_');
                const timestamp = new Date().toISOString().split('T')[0];
                link.download = `selected_boundaries_${layerTypes}_${selectedGraphics.length}_features_${timestamp}.geojson`;
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                // Show detailed success message
                const layerBreakdown = Object.entries(layerCounts)
                    .map(([type, count]) => `${count} ${type}`)
                    .join(', ');
                
                updateStatus(`✅ Downloaded ${selectedGraphics.length} features (${layerBreakdown})`, 'success');
                logMessage(`Downloaded ${selectedGraphics.length} features: ${layerBreakdown}`, 'success');
            }

            // Function to log messages (hidden from console by default)
            function logMessage(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = {
                    timestamp: timestamp,
                    message: message,
                    type: type
                };
                logMessages.push(logEntry);
                
                // Only log to console if debugging is enabled
                if (isLoggingEnabled) {
                    console.log(`[${timestamp}] ${message}`);
                }
            }

            // Function to enable/disable console logging
            function toggleLogging() {
                isLoggingEnabled = !isLoggingEnabled;
                const button = document.getElementById('toggleLoggingBtn');
                if (button) {
                    button.textContent = isLoggingEnabled ? 'Disable Logging' : 'Enable Logging';
                    button.style.backgroundColor = isLoggingEnabled ? '#FF6B6B' : '#29A8DD';
                }
                updateStatus(`Console logging ${isLoggingEnabled ? 'enabled' : 'disabled'}`, 'info');
            }

            // Function to show all stored logs
            function showLogs() {
                const logWindow = window.open('', '_blank', 'width=800,height=600');
                logWindow.document.write(`
                    <html>
                    <head>
                        <title>PSAP Map Logs</title>
                        <style>
                            body { font-family: monospace; font-size: 12px; margin: 20px; }
                            .log-entry { margin: 5px 0; padding: 5px; border-left: 3px solid #ccc; }
                            .log-entry.info { border-left-color: #29A8DD; }
                            .log-entry.success { border-left-color: #4CAF50; }
                            .log-entry.error { border-left-color: #FF6B6B; }
                            .log-entry.warning { border-left-color: #FFA726; }
                            .timestamp { color: #666; font-weight: bold; }
                            .message { margin-left: 10px; }
                            .controls { margin-bottom: 20px; }
                            button { margin: 5px; padding: 8px 12px; cursor: pointer; }
                        </style>
                    </head>
                    <body>
                        <h2>PSAP Map Application Logs</h2>
                        <div class="controls">
                            <button onclick="window.print()">Print Logs</button>
                            <button onclick="document.getElementById('logs').innerHTML = ''">Clear Logs</button>
                            <button onclick="window.close()">Close</button>
                        </div>
                        <div id="logs">
                            ${logMessages.map(log => `
                                <div class="log-entry ${log.type}">
                                    <span class="timestamp">[${log.timestamp}]</span>
                                    <span class="message">${log.message}</span>
                                </div>
                            `).join('')}
                        </div>
                    </body>
                    </html>
                `);
            }

            // Make functions globally available
            window.loadPSAPData = loadPSAPData;
            window.clearMap = clearMap;
            window.zoomToUS = zoomToUS;
            window.closePopup = closePopup;
            window.clearSearch = clearSearch;
            window.selectSearchResult = selectSearchResult;
            window.toggleUSGSLayer = toggleUSGSLayer;
            window.showSearchStatus = showSearchStatus;
            window.refreshSearchDatabase = refreshSearchDatabase;
            window.toggleCountyLayer = toggleCountyLayer;
            window.toggleStateLayer = toggleStateLayer;
            window.showAllLayers = showAllLayers;
            window.hideAllLayers = hideAllLayers;
            window.showLayerForGraphic = showLayerForGraphic;
            window.testCountySearch = testCountySearch; // Add the new test function
            window.loadFallbackUSGSData = loadFallbackUSGSData; // Add the fallback function
            window.debugLayerStatus = debugLayerStatus; // Add the debug function
            window.highlightLayerTemporarily = highlightLayerTemporarily; // Add the highlight function
            window.showBoundariesForCurrentView = showBoundariesForCurrentView; // Add the new boundary function
            window.clearAllBoundaries = clearAllBoundaries; // Add the new boundary function
            window.logMessage = logMessage; // Add the new logging function
            window.toggleLogging = toggleLogging; // Add the new logging function
            window.showLogs = showLogs; // Add the new logging function
            window.toggleSelectionMode = toggleSelectionMode; // Add selection mode function
            window.showSelectionSummary = showSelectionSummary; // Add selection summary function
            window.downloadSelected = downloadSelected; // Add download function
            window.clearSelection = clearSelection; // Add clear selection function
            window.loadCanadianData = loadCanadianData; // Add Canadian data loading function
            
            logMessage('Map ready! All layers will load automatically.', 'info');
            
            // Auto-load PSAP data when page loads
            setTimeout(async () => {
                await loadPSAPData();
            }, 1000);
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>PSAP Interactive Map</title>

    <link rel="stylesheet" href="https://js.arcgis.com/4.28/esri/themes/light/main.css">
    <script src="https://js.arcgis.com/4.28/"></script>

    <style>
        /* Tutorial Overlay Styles */
        #tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        .tutorial-container {
            background: white;
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        
        .tutorial-header {
            background: var(--royal-blue);
            color: white;
            padding: 15px 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .tutorial-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0 5px;
        }
        
        .tutorial-content {
            padding: 20px;
        }
        
        .tutorial-step {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        
        .tutorial-step:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .tutorial-step h3 {
            color: var(--royal-blue);
            margin-top: 0;
        }
        
        .tutorial-step p {
            margin: 10px 0;
            line-height: 1.5;
        }
        
        .tutorial-step kbd {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 0.9em;
            box-shadow: 0 1px 1px rgba(0,0,0,0.1);
        }
        
        .tutorial-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .tutorial-button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .tutorial-button.primary {
            background: var(--safety-blue);
            color: white;
        }
        
        .tutorial-button.secondary {
            background: #f0f0f0;
            color: #333;
        }
        
        .tutorial-step-number {
            display: inline-block;
            background: var(--safety-blue);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            margin-right: 10px;
            font-weight: bold;
        }

        /* RapidSOS brand colors */
        :root {
            --royal-blue: #001559; /* Primary dark blue */
            --safety-blue: #29A8DD; /* Primary light blue */
            --white: #FFFFFF;
            --safety-gap: #FFF300; /* Yellow highlight */
            --glow: #005eFF; /* Bright blue highlight */
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(41, 168, 221, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(41, 168, 221, 0); }
            100% { box-shadow: 0 0 0 0 rgba(41, 168, 221, 0); }
        }
        
        .drawing-tools-highlight {
            animation: pulse 2s ease-in-out;
            border: 2px solid var(--safety-blue) !important;
            border-radius: 4px;
        }

        html, body, #viewDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
            font-family: Arial, sans-serif;
        }

        .toolbar {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toolbar button {
            background: var(--royal-blue);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            min-width: 180px;
            text-align: left;
        }

        .toolbar button:hover {
            background: var(--glow);
        }

        .toolbar button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .toolbar button.active {
            background: #28a745;
        }

        .toolbar button.danger {
            background: #dc3545;
        }

        .toolbar button.danger:hover {
            background: #c82333;
        }
        
        /* Help Button */
        .help-button {
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            margin-left: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: inherit;
            font-size: 14px;
        }
        
        .help-button:hover {
            background: #f5f5f5;
        }
        
        .help-button:hover {
            background: var(--safety-blue);
            transform: scale(1.1);
        }
        
        .help-button svg {
            width: 20px;
            height: 20px;
        }

        #selectionPanel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            max-height: 400px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 100;
            display: none;
            overflow: hidden;
        }

        .panel-header {
            background: var(--royal-blue);
            color: white;
            padding: 12px 16px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-content {
            max-height: 300px;
            overflow-y: auto;
            padding: 0;
        }

        .selected-item {
            padding: 12px 16px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
        }

        .selected-item:hover {
            background: #f8f9fa;
        }

        .selected-item:last-child {
            border-bottom: none;
        }

        .item-name {
            font-weight: 500;
            color: #333;
            flex-grow: 1;
        }

        .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .remove-btn:hover {
            background: #c82333;
        }

        .panel-footer {
            padding: 12px 16px;
            background: #f8f9fa;
            border-top: 1px solid #eee;
            text-align: center;
            font-size: 12px;
            color: #666;
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .tooltip {
            position: fixed;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 200px;
            word-wrap: break-word;
        }
        
        /* Search bar styles */
        .search-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            width: 300px;
            display: flex;
            flex-direction: column;
        }
        
        .search-input-container {
            display: flex;
            width: 100%;
        }
        
        .search-input {
            flex-grow: 1;
            padding: 10px 15px;
            border: 2px solid var(--safety-blue);
            border-right: none;
            border-radius: 4px 0 0 4px;
            font-size: 14px;
        }
        
        .search-button {
            background: var(--safety-blue);
            color: white;
            border: none;
            padding: 0 15px;
            border-radius: 0 4px 4px 0;
            cursor: pointer;
        }
        
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 400px;
            overflow-y: auto;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .search-result-item {
            padding: 12px 15px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .search-result-item:last-child {
            border-bottom: none;
        }
        
        .search-result-item:hover {
            background-color: #f8f9fa;
        }
        
        .search-result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .search-result-title {
            font-weight: 600;
            font-size: 14px;
            color: #333;
        }
        
        .search-result-type {
            font-size: 12px;
            color: #6c757d;
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 10px;
        }
        
        .search-result-details {
            font-size: 13px;
            color: #6c757d;
            margin: 8px 0;
            max-height: 100px;
            overflow-y: auto;
            padding-right: 5px;
        }
        
        .search-result-detail {
            margin-bottom: 4px;
            line-height: 1.4;
        }
        
        .search-result-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        .search-result-actions .btn {
            font-size: 12px;
            padding: 3px 8px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .no-details {
            color: #adb5bd;
            font-style: italic;
            font-size: 12px;
        }
        
        /* Area Selection Modal Styles */
        .modal {
            display: block;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
        }
        
        .modal-content {
            position: relative;
            background-color: #fff;
            margin: 10% auto;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            width: 400px;
            max-width: 80%;
            text-align: center;
        }
        
        .modal h2 {
            margin-top: 0;
            color: #333;
        }
        
        .modal p {
            margin-bottom: 20px;
            font-size: 16px;
            color: #555;
        }
        
        .modal-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .select-area-btn {
            padding: 12px 15px;
            border: none;
            border-radius: 5px;
            background-color: #2b6da8;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .select-area-btn:hover {
            background-color: #3980bd;
            transform: translateY(-2px);
        }
        
        .select-area-btn:active {
            transform: translateY(0);
        }
    </style>
</head>

<body>
    <!-- Help Button has been moved to the toolbar below -->
    
    <div id="viewDiv"></div>
    
    <!-- Tutorial Overlay -->
    <div id="tutorial-overlay">
        <div class="tutorial-container">
            <div class="tutorial-header">
                <h2>PSAP Map Tutorial</h2>
                <button class="tutorial-close">&times;</button>
            </div>
            <div class="tutorial-content">
                <div class="tutorial-step">
                    <h3><span class="tutorial-step-number">1</span>Selecting Features</h3>
                    <p>Click on any PSAP or Canadian town to select it. Selected features will be highlighted.</p>
                    <p>To select multiple features:</p>
                    <ul>
                        <li>Hold <kbd>Ctrl</kbd> (Windows) or <kbd>‚åò</kbd> (Mac) while clicking</li>
                        <li>Or enable <strong>Multi-Select Mode</strong> to select multiple features without holding keys</li>
                    </ul>
                </div>
                
                <div class="tutorial-step">
                    <h3><span class="tutorial-step-number">2</span>Switching Between Layers</h3>
                    <p>Use the <strong>Focus</strong> button in the top-right to switch between US PSAPs and Canadian Towns layers.</p>
                    <p>The active layer will be highlighted, and the search will only look in the currently selected layer.</p>
                </div>
                
                <div class="tutorial-step">
                    <h3><span class="tutorial-step-number">3</span>Searching for Locations</h3>
                    <p>Use the search bar in the middle of the page to find specific PSAPs or Canadian towns.</p>
                    <ul>
                        <li>Searches are case-insensitive and look for partial matches</li>
                        <li>For Canadian Towns, search by the town name in the CSDNAME field</li>
                        <li>For PSAPs, search by PSAP name, account ID, or name</li>
                    </ul>
                    <p>Click on a search result to zoom to that location and select it.</p>
                </div>
                
                <div class="tutorial-step">
                    <h3><span class="tutorial-step-number">4</span>Managing Selections</h3>
                    <p>View your selected features in the panel on the left. You can:</p>
                    <ul>
                        <li>Click the <strong>√ó</strong> next to an item to remove it</li>
                        <li>Click <strong>Clear All</strong> to remove all selections</li>
                        <li>Click <strong>Download Selected</strong> to export your selection as GeoJSON</li>
                    </ul>
                </div>
                
                <div class="tutorial-step">
                    <h3><span class="tutorial-step-number">5</span>Drawing Tools</h3>
                    <p>Use the drawing tools to create custom areas of interest:</p>
                    <ul>
                        <li>Click the <strong>Draw Polygon</strong> button to start drawing</li>
                        <li>After clicking, the drawing tools will appear in the bottom-right corner of the map</li>
                        <li>Use these tools to draw different shapes:
                            <ul>
                                <li>Point: Draw individual points</li>
                                <li>Line: Draw line segments</li>
                                <li>Polygon: Draw custom shapes (selected by default)</li>
                                <li>Rectangle: Draw rectangular areas</li>
                                <li>Circle: Draw circular areas</li>
                                <li>Trash: Delete the current drawing</li>
                                <li>Complete: Finish and save your drawing</li>
                            </ul>
                        </li>
                        <li>When drawing a polygon:
                            <ul>
                                <li>Click on the map to add each vertex of your shape</li>
                                <li>Double-click or click <strong>Complete</strong> to finish the shape</li>
                                <li>Click <strong>Trash</strong> to start over</li>
                            </ul>
                        </li>
                        <li>Download your drawn areas using the download button</li>
                    </ul>
                    <div style="margin-top: 10px; padding: 10px; background-color: #f8f9fa; border-radius: 4px;">
                        <strong>üí° Tip:</strong> The drawing tools will be highlighted with a blue border when active
                    </div>
                </div>
                
                <div class="tutorial-buttons">
                    <button class="tutorial-button secondary" id="dontShowAgain">Don't Show Again</button>
                    <button class="tutorial-button primary" id="tutorialGotIt">Got it, thanks!</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Search Bar -->
    <div class="search-container">
        <div class="search-input-container">
            <input type="text" class="search-input" id="searchInput" placeholder="Search for a PSAP...">
            <button class="search-button" id="searchButton">üîç</button>
        </div>
        <div class="search-results" id="searchResults"></div>
    </div>
    
    <!-- Toolbar for multiselect and downloads -->
    <div class="toolbar" id="toolbar">
        <button id="layerSwitchBtn">Focus: US PSAPs</button>
        <button id="multiSelectBtn">üîò Multi-Select: ON</button>
        <button id="loadKoordinatesBtn">üåê Load Koordinates Data</button>
        <button id="drawPolygonBtn">‚úèÔ∏è Draw Polygon</button>
        <button id="downloadBtn" disabled>üì• Download Selected (0)</button>
        <button id="downloadDrawnBtn" style="display:none;">üì• Download Drawn Polygon</button>
        <button id="clearAllBtn" disabled class="danger">‚ùå Clear Selection</button>
        <button id="helpButton" class="help-button" title="Show Map Tutorial">üìö Map Tutorial</button>
    </div>
    
    <!-- Selection Panel -->
    <div id="selectionPanel">
        <div class="panel-header">
            <span id="selectionHeaderText">Selected Features</span> (<span id="selectionCount">0</span>)
            <span id="panelToggle" style="cursor: pointer;">‚àí</span>
        </div>
        <div class="panel-content" id="selectionList">
            <!-- Selected items will be populated here -->
        </div>
        <div class="panel-footer">
            Multiple selection is enabled by default. Hold Ctrl/Cmd + click to add more.
        </div>
    </div>

    <div id="status">Single-click to select PSAPs. For multiple: Hold Cmd/Ctrl or Multi-Select Mode.</div>
    
    <!-- Area Selection Modal -->
    <div id="areaSelectionModal" class="modal">
        <div class="modal-content">
            <h2>Select Area</h2>
            <p>Which area would you like to work with?</p>
            <div class="modal-buttons">
                <button id="selectUSBtn" class="select-area-btn">United States</button>
                <button id="selectCanadaBtn" class="select-area-btn">Canada</button>
                <button id="selectDefaultBtn" class="select-area-btn">Other (Default)</button>
            </div>
        </div>
    </div>

    <script>
        require([
            "esri/config",
            "esri/identity/IdentityManager",
            "esri/Map",
            "esri/views/MapView",
            "esri/layers/FeatureLayer",
            "esri/symbols/SimpleFillSymbol",
            "esri/symbols/SimpleLineSymbol",
            "esri/symbols/SimpleMarkerSymbol",
            "esri/renderers/SimpleRenderer",
            "esri/Graphic",
            "esri/geometry/geometryEngine",
            "esri/widgets/Sketch",
            "esri/layers/GraphicsLayer",
            "esri/geometry/projection",
            "esri/geometry/SpatialReference",
            "esri/widgets/Expand"
        ], function(esriConfig, IdentityManager, Map, MapView, FeatureLayer, SimpleFillSymbol, SimpleLineSymbol, SimpleMarkerSymbol, SimpleRenderer, Graphic, geometryEngine, Sketch, GraphicsLayer, projection, SpatialReference, Expand) {

            // Configure ArcGIS to disable authentication prompts and allow anonymous access
            esriConfig.request.interceptors.push({
                urls: [
                    "https://services3.arcgis.com/8lRAGVDTn4JslcF7/arcgis/rest/services/"
                ],
                before: function(params) {
                    // Force anonymous access by not sending any authentication headers
                    params.requestOptions = params.requestOptions || {};
                    params.requestOptions.headers = params.requestOptions.headers || {};
                    // Remove any potential auth headers
                    delete params.requestOptions.headers.Authorization;
                    delete params.requestOptions.headers['X-Esri-Authorization'];
                }
            });

            // Disable the identity manager to prevent login prompts
            esriConfig.request.useIdentity = false;
            
            // Explicitly disable IdentityManager
            IdentityManager.destroyCredentials();
            IdentityManager.checkSignInStatus = function() { return false; };
            
            // Additional configuration to prevent authentication prompts
            esriConfig.request.timeout = 60000; // Set a reasonable timeout
            esriConfig.request.httpsDomains.push("services3.arcgis.com"); // Trust the domain

            // Koordinates API configuration
            const KOORDINATES_API_KEY = '[api_token]'; // Replace with your actual API key
            const KOORDINATES_LAYER_ID = '112378';
            const KOORDINATES_BASE_URL = 'https://koordinates.com/services/query/v1/vector.json';
            
            // Statistics Canada Digital Boundary Files configuration
            const STATCAN_BASE_URL = 'https://geo.statcan.gc.ca/geo_wa/rest/services/2021/Digital_boundary_files/MapServer';

            // Initialize variables
            let sketchGraphicsLayer;
            let drawnPolygon = null;
            let selectedFeatures = [];
            let highlightSelections = [];
            let psapLayerView;
            let canadaTownsLayerView;
            let statcanCSDLayerView;
            let activeLayer = 'psap'; // Default to PSAP layer
            let multiSelectMode = true; // Default multi-select to ON
            let drawnPolygons = [];
            let drawingMode = false; // Used in toggleDrawingMode
            let sketch = null; // For sketch widget

            // UI Elements
            const downloadBtn = document.getElementById('downloadBtn');
            const downloadDrawnBtn = document.getElementById('downloadDrawnBtn');
            const clearAllBtn = document.getElementById('clearAllBtn');
            const multiSelectBtn = document.getElementById('multiSelectBtn');
            const drawPolygonBtn = document.getElementById('drawPolygonBtn');
            const selectionPanel = document.getElementById('selectionPanel');
            const selectionList = document.getElementById('selectionList');
            const selectionCount = document.getElementById('selectionCount');
            const panelToggle = document.getElementById('panelToggle');
            const status = document.getElementById('status');
            const searchInput = document.getElementById('searchInput');
            const searchButton = document.getElementById('searchButton');
            const searchResults = document.getElementById('searchResults');

            // Create the map
            const map = new Map({
                basemap: "hybrid"
            });

            // Create the map view
            const view = new MapView({
                container: "viewDiv",
                map: map,
                center: [-98.5795, 39.8283], // Center of US
                zoom: 4
            });

            // Define renderer for the layer
            const renderer = new SimpleRenderer({
                symbol: new SimpleFillSymbol({
                    color: [41, 168, 221, 0.4], // Light blue with transparency
                    outline: new SimpleLineSymbol({
                        color: [0, 21, 89, 0.8], // Dark blue outline
                        width: 1
                    })
                })
            });

            // Create a graphics layer for PSAP data that will be loaded via proxy
            const psapLayer = new GraphicsLayer({
                title: "PSAP 911 Service Areas",
                visible: true,
                opacity: 1.0
            });
            

            
            // COMPREHENSIVE TESTING: All PSAP services for systematic testing
            const allPSAPServices = [
                // KNOWN WORKING
                {
                    name: "Alabama PSAP Centers",
                    url: "https://services2.arcgis.com/Ao3oYLThb9Xbvgpw/arcgis/rest/services/Alabama_911_Centers/FeatureServer/1",
                    state: "AL",
                    expected: "WORKING"
                },
                {
                    name: "Arizona PSAP Boundaries", 
                    url: "https://server.azgeo.az.gov/arcgis/rest/services/az911/Arizona_PSAP_Boundary/FeatureServer/1",
                    state: "AZ",
                    expected: "WORKING"
                },
                // TO TEST
                {
                    name: "Arkansas PSAP Boundaries",
                    url: "https://gis.arkansas.gov/arcgis/rest/services/FEATURESERVICES/Boundaries/FeatureServer/28",
                    state: "AR",
                    expected: "UNKNOWN"
                },
                {
                    name: "Colorado PSAP Review",
                    url: "https://services3.arcgis.com/DgjqnJA1rgO92Soi/arcgis/rest/services/Colorado_PSAP_Review/FeatureServer/1",
                    state: "CO",
                    expected: "UNKNOWN"
                },
                {
                    name: "Georgia PSAP Boundaries",
                    url: "https://services7.arcgis.com/Za9Nk6CPIPbvR1t7/arcgis/rest/services/Georgia_PSAP_Boundaries/FeatureServer/0",
                    state: "GA",
                    expected: "UNKNOWN"
                },
                {
                    name: "Illinois PSAPs and DIGBs",
                    url: "https://services1.arcgis.com/CNPdEkvnGl65jCX8/ArcGIS/rest/services/PSAPs_and_DIGBs_for_planning_purposes/FeatureServer/1",
                    state: "IL",
                    expected: "UNKNOWN"
                },
                {
                    name: "Kansas ESB",
                    url: "https://services6.arcgis.com/7XhimSpf8B7lHIMy/arcgis/rest/services/Kansas_ESB/FeatureServer/0",
                    state: "KS",
                    expected: "UNKNOWN"
                },
                {
                    name: "Kentucky PSAP Boundaries",
                    url: "https://services3.arcgis.com/ghsX9CKghMvyYjBU/arcgis/rest/services/Ky_911_PSAP_Boundaries_gdb/FeatureServer/0",
                    state: "KY",
                    expected: "UNKNOWN"
                },
                {
                    name: "Louisiana PSAP Service Areas",
                    url: "https://services1.arcgis.com/fXHQyq63u0UsTeSM/arcgis/rest/services/LA_PSAP_SERVICE_AREA_BOUNDARIES/FeatureServer/0",
                    state: "LA",
                    expected: "UNKNOWN"
                },
                {
                    name: "Michigan PSAP Boundaries",
                    url: "https://gisagocss.state.mi.us/arcgis/rest/services/OpenData/boundaries/MapServer/8",
                    state: "MI",
                    expected: "UNKNOWN"
                },
                {
                    name: "Minnesota Emergency Service Zones",
                    url: "https://services.arcgis.com/9OIuDHbyhmH91RfZ/arcgis/rest/services/Minnesota_Emergency_Service_and_Law_Enforcement_Zones_-_(New_View_Layer)_updated/FeatureServer/0",
                    state: "MN",
                    expected: "UNKNOWN"
                },
                {
                    name: "Mississippi PSAP Service Areas",
                    url: "https://gis.mississippi.edu/server/rest/services/Administrative/MS_911PSAPServAreas_2009/MapServer/0",
                    state: "MS",
                    expected: "UNKNOWN"
                },
                {
                    name: "Missouri PSAP Boundaries",
                    url: "https://services9.arcgis.com/YNsLkqewm6stuiL9/arcgis/rest/services/PSAP_Boundaries_WFL1/FeatureServer/0",
                    state: "MO",
                    expected: "UNKNOWN"
                },
                {
                    name: "Montana 911 PSAP Jurisdictions",
                    url: "https://services.arcgis.com/qnjIrwR8z5Izc0ij/arcgis/rest/services/Montana_9_1_1_PSAP_Jurisdictions/FeatureServer/0",
                    state: "MT",
                    expected: "UNKNOWN"
                },
                {
                    name: "Nebraska PSAP Boundaries",
                    url: "https://gis.ne.gov/Enterprise/rest/services/Public_Safety_Answering_Point_Boundaries/FeatureServer/0",
                    state: "NE",
                    expected: "UNKNOWN"
                },
                {
                    name: "Nevada PSAP Boundaries",
                    url: "https://services3.arcgis.com/5GeA0r0IN0Q5uQUC/arcgis/rest/services/PSAP_boundaries/FeatureServer/1",
                    state: "NV",
                    expected: "UNKNOWN"
                },
                {
                    name: "North Carolina PSAPs",
                    url: "https://services5.arcgis.com/mSDBiLWaIfH92NqI/arcgis/rest/services/NC911_PSAPs/FeatureServer/0",
                    state: "NC",
                    expected: "UNKNOWN"
                },
                {
                    name: "North Dakota PSAP Boundaries",
                    url: "https://services8.arcgis.com/gHHsN1i8OISt9wMD/arcgis/rest/services/PSAP_BOUNDARIES/FeatureServer/0",
                    state: "ND",
                    expected: "UNKNOWN"
                },
                {
                    name: "South Carolina ESINet",
                    url: "https://services9.arcgis.com/RvqSyw3diI7dTKo5/arcgis/rest/services/SC_ESINet/FeatureServer/0",
                    state: "SC",
                    expected: "UNKNOWN"
                },
                {
                    name: "South Dakota PSAP Service Areas",
                    url: "https://services1.arcgis.com/p8X5J3QcVNXr7lJO/arcgis/rest/services/Public_Safety_Answering_Points_PSAP_/FeatureServer/0",
                    state: "SD",
                    expected: "UNKNOWN"
                },
                {
                    name: "Texas A&M Emergency Communication Boundaries",
                    url: "https://services.gis.txdot.gov/public/rest/services/TPP/TxDOT_TTP_Emergency_Communication_Boundaries/MapServer/0",
                    state: "TX",
                    expected: "UNKNOWN"
                },
                {
                    name: "Vermont PSAP Service Areas",
                    url: "https://maps.vermont.gov/arcgis/rest/services/EGC_services/OPENDATA_VCGI_E911_SP_NOCACHE_v2/MapServer/102",
                    state: "VT",
                    expected: "UNKNOWN"
                },
                {
                    name: "Virginia PSAP Primary Service Area",
                    url: "https://vgin.vdem.virginia.gov/arcgis/rest/services/PSAP_Primary_Service_Area/FeatureServer/0",
                    state: "VA",
                    expected: "UNKNOWN"
                },
                {
                    name: "West Virginia PSAP Service Areas",
                    url: "https://services1.arcgis.com/rEf4Uw7S95MQIN7A/arcgis/rest/services/Public_Safety_Answering_Points_2020/FeatureServer/0",
                    state: "WV",
                    expected: "UNKNOWN"
                },
                {
                    name: "Wisconsin Public Safety Answering Points",
                    url: "https://data-wi-dnr.opendata.arcgis.com/datasets/wisconsin-public-safety-answering-points/FeatureServer/0",
                    state: "WI",
                    expected: "UNKNOWN"
                }
            ];

            // PRODUCTION: Only the 12 verified working services from testing
            const workingPSAPServices = [
                {
                    name: "Alabama PSAP Centers",
                    url: "https://services2.arcgis.com/Ao3oYLThb9Xbvgpw/arcgis/rest/services/Alabama_911_Centers/FeatureServer/1",
                    state: "AL",
                    expected: "WORKING"
                },
                {
                    name: "Arizona PSAP Boundaries",
                    url: "https://server.azgeo.az.gov/arcgis/rest/services/az911/Arizona_PSAP_Boundary/FeatureServer/1",
                    state: "AZ",
                    expected: "WORKING"
                },
                {
                    name: "Arkansas PSAP Boundaries",
                    url: "https://gis.arkansas.gov/arcgis/rest/services/FEATURESERVICES/Boundaries/FeatureServer/28",
                    state: "AR",
                    expected: "WORKING"
                },
                {
                    name: "Colorado PSAP Review",
                    url: "https://services3.arcgis.com/DgjqnJA1rgO92Soi/arcgis/rest/services/Colorado_PSAP_Review/FeatureServer/1",
                    state: "CO",
                    expected: "WORKING"
                },
                {
                    name: "Illinois PSAPs and DIGBs",
                    url: "https://services1.arcgis.com/CNPdEkvnGl65jCX8/ArcGIS/rest/services/PSAPs_and_DIGBs_for_planning_purposes/FeatureServer/1",
                    state: "IL",
                    expected: "WORKING"
                },
                {
                    name: "Kansas ESB",
                    url: "https://services6.arcgis.com/7XhimSpf8B7lHIMy/arcgis/rest/services/Kansas_ESB/FeatureServer/0",
                    state: "KS",
                    expected: "WORKING"
                },
                {
                    name: "Michigan PSAP Boundaries",
                    url: "https://gisagocss.state.mi.us/arcgis/rest/services/OpenData/boundaries/MapServer/8",
                    state: "MI",
                    expected: "WORKING"
                },
                {
                    name: "Mississippi PSAP Service Areas",
                    url: "https://gis.mississippi.edu/server/rest/services/Administrative/MS_911PSAPServAreas_2009/MapServer/0",
                    state: "MS",
                    expected: "WORKING"
                },
                {
                    name: "Missouri PSAP Boundaries",
                    url: "https://services9.arcgis.com/YNsLkqewm6stuiL9/arcgis/rest/services/PSAP_Boundaries_WFL1/FeatureServer/0",
                    state: "MO",
                    expected: "WORKING"
                },
                {
                    name: "Nebraska PSAP Boundaries",
                    url: "https://gis.ne.gov/Enterprise/rest/services/Public_Safety_Answering_Point_Boundaries/FeatureServer/0",
                    state: "NE",
                    expected: "WORKING"
                },
                {
                    name: "Nevada PSAP Boundaries",
                    url: "https://services3.arcgis.com/5GeA0r0IN0Q5uQUC/arcgis/rest/services/PSAP_boundaries/FeatureServer/1",
                    state: "NV",
                    expected: "WORKING"
                },
                {
                    name: "North Dakota PSAP Boundaries",
                    url: "https://services8.arcgis.com/gHHsN1i8OISt9wMD/arcgis/rest/services/PSAP_BOUNDARIES/FeatureServer/0",
                    state: "ND",
                    expected: "WORKING"
                }
            ];

            // Legacy reference
            const fastPSAPServices = workingPSAPServices;

            // DEPRECATED: Old slow service array (kept for reference)
            const statePSAPServices = [
                {
                    name: "Arkansas PSAP Boundaries",
                    url: "https://gis.arkansas.gov/arcgis/rest/services/FEATURESERVICES/Boundaries/FeatureServer/28",
                    state: "AR"
                },
                {
                    name: "Colorado PSAP Review",
                    url: "https://services3.arcgis.com/DgjqnJA1rgO92Soi/arcgis/rest/services/Colorado_PSAP_Review/FeatureServer/1",
                    state: "CO"
                },
                {
                    name: "Georgia PSAP Boundaries",
                    url: "https://services7.arcgis.com/Za9Nk6CPIPbvR1t7/arcgis/rest/services/Georgia_PSAP_Boundaries/FeatureServer/0",
                    state: "GA"
                },
                {
                    name: "Illinois PSAPs and DIGBs",
                    url: "https://services1.arcgis.com/CNPdEkvnGl65jCX8/ArcGIS/rest/services/PSAPs_and_DIGBs_for_planning_purposes/FeatureServer/1",
                    state: "IL"
                },
                {
                    name: "Kansas ESB",
                    url: "https://services6.arcgis.com/7XhimSpf8B7lHIMy/arcgis/rest/services/Kansas_ESB/FeatureServer/0",
                    state: "KS"
                },
                {
                    name: "Kentucky PSAP Boundaries",
                    url: "https://services3.arcgis.com/ghsX9CKghMvyYjBU/arcgis/rest/services/Ky_911_PSAP_Boundaries_gdb/FeatureServer/0",
                    state: "KY"
                },
                {
                    name: "Louisiana PSAP Service Areas",
                    url: "https://services1.arcgis.com/fXHQyq63u0UsTeSM/arcgis/rest/services/LA_PSAP_SERVICE_AREA_BOUNDARIES/FeatureServer/0",
                    state: "LA"
                },
                {
                    name: "Michigan PSAP Boundaries",
                    url: "https://gisagocss.state.mi.us/arcgis/rest/services/OpenData/boundaries/MapServer/8",
                    state: "MI"
                },
                {
                    name: "Minnesota Emergency Service Zones",
                    url: "https://services.arcgis.com/9OIuDHbyhmH91RfZ/arcgis/rest/services/Minnesota_Emergency_Service_and_Law_Enforcement_Zones_-_(New_View_Layer)_updated/FeatureServer/0",
                    state: "MN"
                },
                {
                    name: "Mississippi PSAP Service Areas",
                    url: "https://gis.mississippi.edu/server/rest/services/Administrative/MS_911PSAPServAreas_2009/MapServer/0",
                    state: "MS"
                },
                {
                    name: "Missouri PSAP Boundaries",
                    url: "https://services9.arcgis.com/YNsLkqewm6stuiL9/arcgis/rest/services/PSAP_Boundaries_WFL1/FeatureServer/0",
                    state: "MO"
                },
                {
                    name: "Montana 911 PSAP Jurisdictions",
                    url: "https://services.arcgis.com/qnjIrwR8z5Izc0ij/arcgis/rest/services/Montana_9_1_1_PSAP_Jurisdictions/FeatureServer/0",
                    state: "MT"
                },
                {
                    name: "Nebraska PSAP Boundaries",
                    url: "https://gis.ne.gov/Enterprise/rest/services/Public_Safety_Answering_Point_Boundaries/FeatureServer/0",
                    state: "NE"
                },
                {
                    name: "Nevada PSAP Boundaries",
                    url: "https://services3.arcgis.com/5GeA0r0IN0Q5uQUC/arcgis/rest/services/PSAP_boundaries/FeatureServer/1",
                    state: "NV"
                },
                {
                    name: "North Carolina PSAPs",
                    url: "https://services5.arcgis.com/mSDBiLWaIfH92NqI/arcgis/rest/services/NC911_PSAPs/FeatureServer/0",
                    state: "NC"
                },
                {
                    name: "North Dakota PSAP Boundaries",
                    url: "https://services8.arcgis.com/gHHsN1i8OISt9wMD/arcgis/rest/services/PSAP_BOUNDARIES/FeatureServer/0",
                    state: "ND"
                },
                {
                    name: "South Carolina ESINet",
                    url: "https://services9.arcgis.com/RvqSyw3diI7dTKo5/arcgis/rest/services/SC_ESINet/FeatureServer/0",
                    state: "SC"
                },
                {
                    name: "South Dakota PSAP Boundaries",
                    url: "https://services.arcgis.com/mq0BGE5kHpm8mHFz/arcgis/rest/services/SD_PSAP_Boundaries/FeatureServer/0",
                    state: "SD"
                },
                {
                    name: "Tennessee Emergency Districts",
                    url: "https://services7.arcgis.com/aheAxJpwjYPDjSuN/arcgis/rest/services/TN_Emergency_Districts_Org/FeatureServer/3",
                    state: "TN"
                },
                {
                    name: "Texas 911 Control Points",
                    url: "https://services.arcgis.com/8vL8ZFWfQxhb4uIP/arcgis/rest/services/Texas_911_Control_Points_WFL1/FeatureServer/3",
                    state: "TX"
                },
                {
                    name: "Utah PSAP Boundaries",
                    url: "https://services1.arcgis.com/99lidPhWCzftIe9K/arcgis/rest/services/UtahPSAP_Boundaries/FeatureServer/0",
                    state: "UT"
                },
                {
                    name: "Vermont Emergency Service Zones",
                    url: "https://services1.arcgis.com/BkFxaEFNwHqX3tAw/arcgis/rest/services/FS_VCGI_OPENDATA_Emergency_ESZ_poly_SP_v1/FeatureServer/0",
                    state: "VT"
                },
                {
                    name: "Virginia PSAP Polygon",
                    url: "https://vginmaps.vdem.virginia.gov/arcgis/rest/services/NG911/NG911_VA_StatePlaneSouth_NAD83_PSAP_Polygon/FeatureServer/0",
                    state: "VA"
                },
                {
                    name: "Wisconsin PSAP Grants",
                    url: "https://services.arcgis.com/mq0BGE5kHpm8mHFz/arcgis/rest/services/WIPSAPGrants/FeatureServer/0",
                    state: "WI"
                },
                {
                    name: "Wyoming PSAP Boundaries",
                    url: "https://services.arcgis.com/jsIt88o09Q0r1j8h/arcgis/rest/services/Public_Safety_Answering_Points_(PSAP)_Boundaries2/FeatureServer/0",
                    state: "WY"
                }
            ];
            
            // COMPREHENSIVE TESTING: Test all PSAP services and generate report
            async function testAllPSAPServices() {
                console.log('üß™ COMPREHENSIVE PSAP SERVICE TESTING STARTING...');
                console.log('üìã Testing', allPSAPServices.length, 'PSAP services...');
                
                if (!status) {
                    console.error('‚ùå status element not found');
                    return;
                }
                
                status.textContent = 'üß™ Testing all PSAP services...';
                
                const testResults = [];
                const startTime = Date.now();
                
                // Test each service with timeout
                for (let i = 0; i < allPSAPServices.length; i++) {
                    const service = allPSAPServices[i];
                    const testStart = Date.now();
                    
                    console.log(`\nüîç [${i+1}/${allPSAPServices.length}] Testing ${service.state}: ${service.name}`);
                    status.textContent = `Testing ${service.state} (${i+1}/${allPSAPServices.length})...`;
                    
                    try {
                        // Test with 5-second timeout
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 5000);
                        
                        const response = await fetch(`${service.url}/query?where=1%3D1&outFields=*&returnGeometry=true&f=json`, {
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);
                        
                        const responseTime = Date.now() - testStart;
                        
                        if (!response.ok) {
                            const result = {
                                state: service.state,
                                name: service.name,
                                url: service.url,
                                status: 'FAILED',
                                httpStatus: response.status,
                                responseTime: responseTime,
                                error: `HTTP ${response.status}`,
                                features: 0
                            };
                            testResults.push(result);
                            console.log(`‚ùå ${service.state}: HTTP ${response.status} (${responseTime}ms)`);
                            continue;
                        }
                        
                        const data = await response.json();
                        const totalTime = Date.now() - testStart;
                        
                        if (!data.features || data.features.length === 0) {
                            const result = {
                                state: service.state,
                                name: service.name,
                                url: service.url,
                                status: 'FAILED',
                                httpStatus: 200,
                                responseTime: responseTime,
                                error: 'No features returned',
                                features: 0
                            };
                            testResults.push(result);
                            console.log(`‚ùå ${service.state}: No features (${totalTime}ms)`);
                            continue;
                        }
                        
                        // Test geometry processing
                        let geometryErrors = 0;
                        let validFeatures = 0;
                        
                        data.features.forEach(feature => {
                            try {
                                let geometry = feature.geometry;
                                if (geometry?.rings && !geometry.type) {
                                    geometry.type = 'polygon';
                                }
                                if (geometry?.rings?.length) {
                                    validFeatures++;
                                } else {
                                    geometryErrors++;
                                }
                            } catch (e) {
                                geometryErrors++;
                            }
                        });
                        
                        const result = {
                            state: service.state,
                            name: service.name,
                            url: service.url,
                            status: 'WORKING',
                            httpStatus: 200,
                            responseTime: responseTime,
                            totalTime: totalTime,
                            error: null,
                            features: data.features.length,
                            validFeatures: validFeatures,
                            geometryErrors: geometryErrors
                        };
                        
                        testResults.push(result);
                        console.log(`‚úÖ ${service.state}: ${data.features.length} features, ${validFeatures} valid (${totalTime}ms)`);
                        
                    } catch (error) {
                        const totalTime = Date.now() - testStart;
                        const result = {
                            state: service.state,
                            name: service.name,
                            url: service.url,
                            status: 'FAILED',
                            httpStatus: null,
                            responseTime: totalTime,
                            error: error.name === 'AbortError' ? 'Timeout' : error.message,
                            features: 0
                        };
                        testResults.push(result);
                        console.log(`‚ùå ${service.state}: ${error.name === 'AbortError' ? 'Timeout' : error.message} (${totalTime}ms)`);
                    }
                    
                    // Small delay between tests to be nice to servers
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                const totalTime = Date.now() - startTime;
                
                // Generate comprehensive report
                console.log('\nüìä COMPREHENSIVE PSAP SERVICE TEST RESULTS');
                console.log('=' .repeat(80));
                console.log(`Total time: ${totalTime}ms`);
                console.log(`Services tested: ${testResults.length}`);
                
                const working = testResults.filter(r => r.status === 'WORKING');
                const failed = testResults.filter(r => r.status === 'FAILED');
                
                console.log(`‚úÖ Working: ${working.length}`);
                console.log(`‚ùå Failed: ${failed.length}`);
                
                console.log('\n‚úÖ WORKING SERVICES:');
                working.forEach(result => {
                    console.log(`  ${result.state}: ${result.name} - ${result.features} features (${result.responseTime}ms)`);
                });
                
                console.log('\n‚ùå FAILED SERVICES:');
                failed.forEach(result => {
                    console.log(`  ${result.state}: ${result.name} - ${result.error} (${result.responseTime}ms)`);
                });
                
                // Generate copy-paste ready results
                console.log('\nüìã COPY-PASTE READY RESULTS:');
                console.log('WORKING SERVICES:');
                working.forEach(result => {
                    console.log(`{
    name: "${result.name}",
    url: "${result.url}",
    state: "${result.state}",
    expected: "WORKING"
},`);
                });
                
                console.log('\nFAILED SERVICES:');
                failed.forEach(result => {
                    console.log(`${result.state}: ${result.error}`);
                });
                
                status.textContent = `Testing complete! ${working.length} working, ${failed.length} failed (${totalTime}ms)`;
                
                // Load working services if any found
                if (working.length > 0) {
                    console.log('\nüöÄ Loading working services...');
                    await loadWorkingServices(working);
                } else {
                    console.log('\n‚ùå No working services found - using demo data');
                    createDemoPSAPBoundaries();
                    status.textContent = 'No working PSAP services - using demo boundaries';
                }
            }
            
            // Load only the working services
            async function loadWorkingServices(workingResults) {
                console.log('üöÄ Loading', workingResults.length, 'working PSAP services...');
                status.textContent = `Loading ${workingResults.length} working PSAP services...`;
                
                let totalFeatures = 0;
                let loadedStates = [];
                
                for (const result of workingResults) {
                    try {
                        console.log(`üì• Loading ${result.state}...`);
                        
                        const response = await fetch(`${result.url}/query?where=1%3D1&outFields=*&returnGeometry=true&f=json`);
                        const data = await response.json();
                        
                        data.features.forEach(feature => {
                            try {
                                let geometry = feature.geometry;
                                if (geometry?.rings && !geometry.type) {
                                    geometry.type = 'polygon';
                                }
                                
                                if (geometry?.rings?.length) {
                                    const graphic = new Graphic({
                                        geometry: geometry,
                                        symbol: new SimpleFillSymbol({
                                            color: [255, 243, 0, 0.3],
                                            outline: new SimpleLineSymbol({
                                                color: [255, 243, 0, 0.8],
                                                width: 1
                                            })
                                        }),
                                        attributes: {
                                            ...feature.attributes,
                                            state: result.state,
                                            service_name: result.name
                                        }
                                    });
                                    psapLayer.add(graphic);
                                    totalFeatures++;
                                }
                            } catch (geoError) {
                                console.log(`‚ö†Ô∏è ${result.state}: Geometry error`);
                            }
                        });
                        
                        loadedStates.push(result.state);
                        console.log(`‚úÖ ${result.state}: Added ${data.features.length} features`);
                        
                    } catch (error) {
                        console.log(`‚ùå ${result.state}: Loading failed - ${error.message}`);
                    }
                }
                
                console.log(`üéâ Loaded ${totalFeatures} total features from ${loadedStates.join(', ')}`);
                status.textContent = `Loaded ${totalFeatures} PSAP features from ${loadedStates.join(', ')}`;
                
                // Auto-zoom to data
                setTimeout(() => {
                    try {
                        if (psapLayer.graphics.length > 0) {
                            zoomToLayerExtent(psapLayer);
                        }
                    } catch (e) {
                        console.log('Auto-zoom failed:', e.message);
                    }
                }, 500);
            }
            
            // Helper function to convert decimal degrees to Web Mercator
            function convertToWebMercator(geometry, state) {
                const sampleRing = geometry?.rings?.[0];
                if (sampleRing && sampleRing.length > 0) {
                    const sampleCoord = sampleRing[0];
                    const isDecimalDegrees = Math.abs(sampleCoord[0]) <= 180 && Math.abs(sampleCoord[1]) <= 90;
                    
                    if (isDecimalDegrees) {
                        console.log(`üîÑ ${state}: Converting decimal degrees to Web Mercator`);
                        // Convert decimal degrees to Web Mercator
                        geometry.rings = geometry.rings.map(ring => 
                            ring.map(coord => {
                                const lon = coord[0];
                                const lat = coord[1];
                                const x = lon * 20037508.34 / 180;
                                const y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180) * 20037508.34 / 180;
                                return [x, y];
                            })
                        );
                        geometry.spatialReference = { wkid: 3857 };
                        console.log(`‚úÖ ${state}: Converted coordinates`);
                    }
                }
                return geometry;
            }
            
            // PRODUCTION: Fast loading of verified working services with coordinate conversion
            async function loadProductionPSAPDataWithConversionV4() {
                console.log('üöÄ PRODUCTION: Loading 12 verified working PSAP services...');
                status.textContent = 'Loading verified PSAP services...';
                
                const startTime = Date.now();
                let totalFeatures = 0;
                let loadedStates = [];
                
                try {
                    // Load all working services in parallel with 8-second timeout
                    const loadPromises = workingPSAPServices.map(async (service) => {
                        try {
                            console.log(`‚ö° Loading ${service.state}...`);
                            
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 8000);
                            
                            const response = await fetch(`${service.url}/query?where=1%3D1&outFields=*&returnGeometry=true&f=json`, {
                                signal: controller.signal
                            });
                            clearTimeout(timeoutId);
                            
                            if (!response.ok) {
                                console.log(`‚ùå ${service.state}: HTTP ${response.status}`);
                                return null;
                            }
                            
                            const data = await response.json();
                            if (!data.features?.length) {
                                console.log(`‚ùå ${service.state}: No features`);
                                return null;
                            }
                            
                            console.log(`‚úÖ ${service.state}: Loaded ${data.features.length} features`);
                            return { service, data };
                            
                        } catch (error) {
                            console.log(`‚ùå ${service.state}: ${error.name === 'AbortError' ? 'Timeout' : error.message}`);
                            return null;
                        }
                    });
                    
                    // Wait for all to complete
                    const results = await Promise.allSettled(loadPromises);
                    
                    // Process successful results
                    results.forEach(result => {
                        if (result.status === 'fulfilled' && result.value) {
                            const { service, data } = result.value;
                            
                            data.features.forEach(feature => {
                                try {
                                    let geometry = feature.geometry;
                                    
                                    // Add missing type for ArcGIS geometries
                                    if (geometry?.rings && !geometry.type) {
                                        geometry.type = 'polygon';
                                    }
                                    
                                    if (geometry?.rings?.length) {
                                        const graphic = new Graphic({
                                            geometry: geometry,
                                            symbol: new SimpleFillSymbol({
                                                color: [255, 243, 0, 0.3],
                                                outline: new SimpleLineSymbol({
                                                    color: [255, 243, 0, 0.8],
                                                    width: 1
                                                })
                                            }),
                                            attributes: {
                                                ...feature.attributes,
                                                state: service.state,
                                                service_name: service.name
                                            }
                                        });
                                        psapLayer.add(graphic);
                                        totalFeatures++;
                                    }
                                } catch (geoError) {
                                    console.log(`‚ö†Ô∏è ${service.state}: Geometry error`);
                                }
                            });
                            
                            loadedStates.push(service.state);
                        }
                    });
                    
                    const loadTime = Date.now() - startTime;
                    console.log(`üéâ PRODUCTION: Loaded ${totalFeatures} features from ${loadedStates.join(', ')} in ${loadTime}ms`);
                    console.log(`üìä Total graphics in PSAP layer: ${psapLayer.graphics.length}`);
                    console.log(`üëÅÔ∏è PSAP Layer visible: ${psapLayer.visible}`);
                    console.log(`üé® PSAP Layer opacity: ${psapLayer.opacity}`);
                    
                    if (totalFeatures > 0) {
                        status.textContent = `Loaded ${totalFeatures} PSAP features from ${loadedStates.length} states (${loadTime}ms)`;
                        
                        // Ensure layer is visible
                        psapLayer.visible = true;
                        psapLayer.opacity = 0.7;
                        console.log('‚úÖ Set PSAP layer visible and opacity');
                        
                        // Force layer refresh
                        if (psapLayerView && psapLayerView.refresh) {
                            psapLayerView.refresh();
                            console.log('üîÑ Refreshed PSAP layer view');
                        }
                        
                        // Auto-zoom to data with better extent calculation
                        setTimeout(() => {
                            try {
                                if (psapLayer.graphics.length > 0) {
                                    console.log(`üó∫Ô∏è Calculating extent for ${psapLayer.graphics.length} graphics...`);
                                    
                                    // Calculate extent manually since zoomToLayerExtent might not be defined
                                    const graphics = psapLayer.graphics.toArray();
                                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                                    let extentCount = 0;
                                    
                                    graphics.forEach(graphic => {
                                        if (graphic.geometry && graphic.geometry.extent) {
                                            const ext = graphic.geometry.extent;
                                            
                                            // Check if coordinates are in decimal degrees and convert
                                            let xmin = ext.xmin, ymin = ext.ymin, xmax = ext.xmax, ymax = ext.ymax;
                                            
                                            if (Math.abs(xmin) <= 180 && Math.abs(ymin) <= 90) {
                                                // Convert decimal degrees to Web Mercator
                                                xmin = xmin * 20037508.34 / 180;
                                                ymin = Math.log(Math.tan((90 + ymin) * Math.PI / 360)) / (Math.PI / 180) * 20037508.34 / 180;
                                                xmax = xmax * 20037508.34 / 180;
                                                ymax = Math.log(Math.tan((90 + ymax) * Math.PI / 360)) / (Math.PI / 180) * 20037508.34 / 180;
                                                console.log(`üîÑ Converted extent from decimal degrees to Web Mercator`);
                                            }
                                            
                                            minX = Math.min(minX, xmin);
                                            minY = Math.min(minY, ymin);
                                            maxX = Math.max(maxX, xmax);
                                            maxY = Math.max(maxY, ymax);
                                            extentCount++;
                                        }
                                    });
                                    
                                    console.log(`üìç Found ${extentCount} graphics with extent data`);
                                    
                                    if (minX !== Infinity) {
                                        const extent = {
                                            xmin: minX,
                                            ymin: minY,
                                            xmax: maxX,
                                            ymax: maxY,
                                            spatialReference: { wkid: 3857 }
                                        };
                                        console.log('üó∫Ô∏è Extent:', extent);
                                        view.goTo(extent, { padding: 50 });
                                        console.log('üó∫Ô∏è Auto-zoomed to PSAP data extent');
                                    } else {
                                        console.log('‚ö†Ô∏è No valid extents found - zooming to US');
                                        view.goTo({ center: [-98.5795, 39.8283], zoom: 4 });
                                    }
                                }
                            } catch (e) {
                                console.log('Auto-zoom failed:', e.message);
                                // Fallback zoom to US
                                view.goTo({ center: [-98.5795, 39.8283], zoom: 4 });
                            }
                        }, 1000);
                    } else {
                        console.log('‚ùå Production loading failed - falling back to testing');
                        await testAllPSAPServices();
                    }
                    
                } catch (error) {
                    console.error('Production PSAP loading failed:', error);
                    await testAllPSAPServices();
                }
            }
            
            // FAST: Load only 2 reliable PSAP services in parallel (legacy)
            async function loadFastPSAPData() {
                
                const startTime = Date.now();
                let totalFeatures = 0;
                let loadedStates = [];
                
                try {
                    // Load both services in parallel with 8-second timeout
                    const loadPromises = fastPSAPServices.map(async (service) => {
                        try {
                            console.log(`‚ö° Starting ${service.state}...`);
                            
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 8000);
                            
                            const response = await fetch(`${service.url}/query?where=1%3D1&outFields=*&returnGeometry=true&f=json`, {
                                signal: controller.signal
                            });
                            clearTimeout(timeoutId);
                            
                            if (!response.ok) {
                                console.log(`‚ùå ${service.state}: HTTP ${response.status}`);
                                return null;
                            }
                            
                            const data = await response.json();
                            if (!data.features?.length) {
                                console.log(`‚ùå ${service.state}: No features`);
                                return null;
                            }
                            
                            console.log(`‚úÖ ${service.state}: Loaded ${data.features.length} features`);
                            return { service, data };
                            
                        } catch (error) {
                            console.log(`‚ùå ${service.state}: ${error.name === 'AbortError' ? 'Timeout' : error.message}`);
                            return null;
                        }
                    });
                    
                    // Wait for all (should be fast)
                    const results = await Promise.allSettled(loadPromises);
                    
                    // Process successful results
                    results.forEach(result => {
                        if (result.status === 'fulfilled' && result.value) {
                            const { service, data } = result.value;
                            
                            data.features.forEach(feature => {
                                try {
                                    let geometry = feature.geometry;
                                    
                                    // Add missing type for ArcGIS geometries
                                    if (geometry?.rings && !geometry.type) {
                                        geometry.type = 'polygon';
                                    }
                                    
                                    if (geometry?.rings?.length) {
                                        const graphic = new Graphic({
                                            geometry: geometry,
                                            symbol: new SimpleFillSymbol({
                                                color: [255, 243, 0, 0.3],
                                                outline: new SimpleLineSymbol({
                                                    color: [255, 243, 0, 0.8],
                                                    width: 1
                                                })
                                            }),
                                            attributes: {
                                                ...feature.attributes,
                                                state: service.state,
                                                service_name: service.name
                                            }
                                        });
                                        psapLayer.add(graphic);
                                        totalFeatures++;
                                    }
                                } catch (geoError) {
                                    console.log(`‚ö†Ô∏è ${service.state}: Geometry error`);
                                }
                            });
                            
                            loadedStates.push(service.state);
                        }
                    });
                    
                    const loadTime = Date.now() - startTime;
                    console.log(`üéâ Fast loading complete! ${totalFeatures} features from ${loadedStates.join(', ')} in ${loadTime}ms`);
                    
                    if (totalFeatures > 0) {
                        status.textContent = `Loaded ${totalFeatures} PSAP features quickly (${loadTime}ms)`;
                        
                        // Auto-zoom to data
                        setTimeout(() => {
                            try {
                                if (psapLayer.graphics.length > 0) {
                                    zoomToLayerExtent(psapLayer);
                                }
                            } catch (e) {
                                console.log('Auto-zoom failed:', e.message);
                            }
                        }, 500);
                    } else {
                        console.log('‚ùå Fast loading failed - falling back to demo');
                        createDemoPSAPBoundaries();
                        status.textContent = 'Using demo PSAP boundaries';
                    }
                    
                } catch (error) {
                    console.error('Fast PSAP loading failed:', error);
                    createDemoPSAPBoundaries();
                    status.textContent = 'Error loading PSAP data - using demo';
                }
            }
            
            // LEGACY: Original slow loading function (now unused)
            async function loadStatePSAPData() {
                console.log('Attempting to load PSAP data from multiple state services...');
                status.textContent = 'Loading PSAP data from state services...';
                
                let loadedStates = [];
                let totalFeatures = 0;
                
                // Try each state service
                for (const service of statePSAPServices) {
                    try {
                        console.log(`Trying ${service.name} (${service.state})...`);
                        
                        const queryUrl = `${service.url}/query?where=1%3D1&outFields=*&returnGeometry=true&f=json`;
                        const response = await fetch(queryUrl);
                        
                        if (!response.ok) {
                            console.log(`‚ùå ${service.state}: HTTP ${response.status} - Skipping`);
                            continue;
                        }
                        
                        const data = await response.json();
                        
                        if (data.features && data.features.length > 0) {
                            console.log(`‚úÖ ${service.state}: Loaded ${data.features.length} features`);
                            
                            data.features.forEach(feature => {
                                try {
                                    // Convert geometry to proper ArcGIS format
                                    let geometry = feature.geometry;
                                    
                                    // If geometry already has rings (ArcGIS format), use it as-is
                                    if (geometry && geometry.rings && Array.isArray(geometry.rings)) {
                                        // Geometry is already in ArcGIS format, no conversion needed
                                        console.log(`‚úÖ ${service.state}: Using existing ArcGIS geometry format`);
                                    }
                                    // If geometry is in GeoJSON format, convert it
                                    else if (geometry && geometry.type) {
                                        // For polygons, ensure rings are properly formatted
                                        if (geometry.type === 'polygon' && geometry.coordinates) {
                                            // Ensure coordinates are in the right format for ArcGIS
                                            const rings = geometry.coordinates;
                                            if (Array.isArray(rings) && rings.length > 0) {
                                                geometry = {
                                                    type: 'polygon',
                                                    rings: rings
                                                };
                                            } else {
                                                console.log(`‚ö†Ô∏è ${service.state}: Invalid polygon coordinates format`);
                                                return; // Skip this feature
                                            }
                                        }
                                        // For multipolygons, flatten to individual polygons
                                        else if (geometry.type === 'multipolygon' && geometry.coordinates) {
                                            geometry.coordinates.forEach((ring, index) => {
                                                if (Array.isArray(ring) && ring.length > 0) {
                                                    const polygonGeometry = {
                                                        type: 'polygon',
                                                        rings: ring
                                                    };
                                                    const polygonGraphic = new Graphic({
                                                        geometry: polygonGeometry,
                                                        symbol: new SimpleFillSymbol({
                                                            color: [255, 243, 0, 0.3],
                                                            outline: new SimpleLineSymbol({
                                                                color: [255, 243, 0, 0.8],
                                                                width: 1
                                                            })
                                                        }),
                                                        attributes: {
                                                            ...feature.attributes,
                                                            state: service.state,
                                                            service_name: service.name
                                                        }
                                                    });
                                                    psapLayer.add(polygonGraphic);
                                                    console.log(`‚ûï Added multipolygon graphic to PSAP layer. Total graphics: ${psapLayer.graphics.length}`);
                                                } else {
                                                    console.log(`‚ö†Ô∏è ${service.state}: Invalid multipolygon ring format at index ${index}`);
                                                }
                                            });
                                            return; // Skip the main graphic creation for multipolygons
                                        }
                                    }
                                    
                                    // Create the graphic with proper error handling
                                    // Validate geometry before creating graphic
                                    // Debug the actual geometry structure
                                    console.log(`üîç ${service.state}: Geometry structure:`, {
                                        hasGeometry: !!geometry,
                                        type: geometry?.type,
                                        hasRings: !!geometry?.rings,
                                        ringsType: Array.isArray(geometry?.rings) ? 'array' : typeof geometry?.rings,
                                        ringsLength: geometry?.rings?.length,
                                        sampleRings: geometry?.rings?.[0]?.slice(0, 2) // Show first 2 coordinates
                                    });
                                    
                                    if (geometry && (
                                        (geometry.rings && Array.isArray(geometry.rings)) ||
                                        (geometry.type === 'polygon' && geometry.rings && Array.isArray(geometry.rings)) ||
                                        (geometry.type === 'point' && geometry.x !== undefined && geometry.y !== undefined)
                                    )) {
                                        // Add type if missing (ArcGIS format)
                                        if (geometry.rings && !geometry.type) {
                                            geometry.type = 'polygon';
                                            console.log(`üîß ${service.state}: Added missing type 'polygon' to geometry`);
                                        }
                                        const graphic = new Graphic({
                                            geometry: geometry,
                                            symbol: new SimpleFillSymbol({
                                                color: [255, 243, 0, 0.3],
                                                outline: new SimpleLineSymbol({
                                                    color: [255, 243, 0, 0.8],
                                                    width: 1
                                                })
                                            }),
                                            attributes: {
                                                ...feature.attributes,
                                                state: service.state,
                                                service_name: service.name
                                            }
                                        });
                                        psapLayer.add(graphic);
                                        console.log(`‚ûï Added graphic to PSAP layer. Total graphics: ${psapLayer.graphics.length}`);
                                    } else {
                                        console.log(`‚ö†Ô∏è ${service.state}: Invalid geometry format - type: ${geometry?.type}, has rings: ${geometry?.rings ? 'yes' : 'no'}, rings array: ${Array.isArray(geometry?.rings) ? 'yes' : 'no'}`);
                                    }
                                } catch (geometryError) {
                                    console.log(`‚ö†Ô∏è ${service.state}: Geometry error for feature - ${geometryError.message}`);
                                    // Try to create a simple point graphic as fallback
                                    try {
                                        if (feature.geometry && feature.geometry.x && feature.geometry.y) {
                                            const pointGraphic = new Graphic({
                                                geometry: {
                                                    type: 'point',
                                                    x: feature.geometry.x,
                                                    y: feature.geometry.y
                                                },
                                                symbol: new SimpleMarkerSymbol({
                                                    color: [255, 243, 0, 0.8],
                                                    size: 6
                                                }),
                                                attributes: {
                                                    ...feature.attributes,
                                                    state: service.state,
                                                    service_name: service.name
                                                }
                                            });
                                            psapLayer.add(pointGraphic);
                                            console.log(`‚ûï Added fallback point graphic to PSAP layer. Total graphics: ${psapLayer.graphics.length}`);
                                        }
                                    } catch (fallbackError) {
                                        console.log(`‚ö†Ô∏è ${service.state}: Fallback graphic creation failed - ${fallbackError.message}`);
                                    }
                                }
                            });
                            
                            loadedStates.push(service.state);
                            totalFeatures += data.features.length;
                        } else {
                            console.log(`‚ùå ${service.state}: No features found`);
                        }
                    } catch (error) {
                        console.log(`‚ùå ${service.state}: Error - ${error.message}`);
                    }
                }
                
                if (loadedStates.length > 0) {
                    console.log(`üéâ Successfully loaded PSAP data from ${loadedStates.length} sources: ${loadedStates.join(', ')}`);
                    console.log(`üìä Total features loaded: ${totalFeatures}`);
                    console.log(`üîç PSAP Layer graphics count: ${psapLayer.graphics.length}`);
                    console.log(`üëÅÔ∏è PSAP Layer visible: ${psapLayer.visible}`);
                    console.log(`üé® PSAP Layer opacity: ${psapLayer.opacity}`);
                    console.log(`üëÅÔ∏è PSAP Layer visible: ${psapLayer.visible}`);
                    console.log(`üìä Total graphics in PSAP layer: ${psapLayer.graphics.length}`);
                    
                    // Calculate and log the extent of all graphics
                    if (psapLayer.graphics.length > 0) {
                        try {
                            const allGraphics = psapLayer.graphics.toArray();
                            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                            
                            allGraphics.forEach(graphic => {
                                if (graphic.geometry && graphic.geometry.extent) {
                                    const ext = graphic.geometry.extent;
                                    minX = Math.min(minX, ext.xmin);
                                    minY = Math.min(minY, ext.ymin);
                                    maxX = Math.max(maxX, ext.xmax);
                                    maxY = Math.max(maxY, ext.ymax);
                                }
                            });
                            
                            if (minX !== Infinity) {
                                console.log(`üìç PSAP Data Extent: X: ${minX.toFixed(2)} to ${maxX.toFixed(2)}, Y: ${minY.toFixed(2)} to ${maxY.toFixed(2)}`);
                            }
                        } catch (extentError) {
                            console.log('‚ö†Ô∏è Could not calculate extent:', extentError.message);
                        }
                    }
                    
                    status.textContent = `Loaded ${totalFeatures} PSAP features from ${loadedStates.length} sources: ${loadedStates.join(', ')}`;
                    
                    // Force a refresh of the layer view
                    if (psapLayerView) {
                        console.log('üîÑ Refreshing PSAP layer view...');
                        try {
                            // Try to refresh the layer view if the method exists
                            if (psapLayerView.refresh) {
                                psapLayerView.refresh();
                            } else {
                                console.log('‚ö†Ô∏è Layer view refresh method not available');
                            }
                        } catch (refreshError) {
                            console.log('‚ö†Ô∏è Layer view refresh failed:', refreshError.message);
                        }
                    }
                    
                    // Try to zoom to Alabama specifically if it's the first state loaded
                    if (loadedStates.includes('AL') && loadedStates.length === 1) {
                        console.log('üéØ Attempting to zoom to Alabama PSAP data...');
                        setTimeout(() => {
                            try {
                                zoomToLayerExtent(psapLayer);
                            } catch (zoomError) {
                                console.log('‚ö†Ô∏è Zoom to Alabama failed:', zoomError.message);
                            }
                        }, 1000);
                    }
                } else {
                    console.log('‚ùå No state PSAP services worked - using demo boundaries');
                    createDemoPSAPBoundaries();
                    status.textContent = 'No state PSAP services available - using demo boundaries';
                }
            }
            
            // Load the PSAP data
            // Use fast production loading with verified working services
            try {
                loadProductionPSAPDataWithConversionV4();
            } catch (error) {
                console.error('Production loading failed, falling back to testing:', error);
                testAllPSAPServices();
            }
            
            // PSAP layer will load via proxy or fallback to demo
            
            // Create graphics layer for drawings
            const drawLayer = new GraphicsLayer({
                title: "User-Drawn Polygons"
            });
            
            // Create graphics layer for Koordinates data
            const koordinatesLayer = new GraphicsLayer({
                title: "Koordinates Data",
                visible: true
            });
            
            // Create a simple graphics layer for Canadian provinces
            const canadaTownsLayer = new GraphicsLayer({
                title: "Canadian Provinces",
                visible: true,
                opacity: 1.0
            });
            
            // Load Canadian data directly from the working URL
            async function loadCanadianData() {
                try {
                    const response = await fetch('https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/Canada_Provinces/FeatureServer/0/query?where=1%3D1&outFields=*&returnGeometry=true&f=json');
                    const data = await response.json();
                    
                    if (data.features) {
                        data.features.forEach(feature => {
                            const graphic = new Graphic({
                                geometry: feature.geometry,
                                symbol: new SimpleFillSymbol({
                                    color: [51, 51, 204, 0.3],
                                    outline: new SimpleLineSymbol({
                                        color: [51, 51, 204, 0.8],
                                        width: 1
                                    })
                                }),
                                attributes: feature.attributes
                            });
                            canadaTownsLayer.add(graphic);
                        });
                        console.log(`Loaded ${data.features.length} Canadian province features`);
                    }
                } catch (error) {
                    console.error('Error loading Canadian data:', error);
                }
            }
            
            // Load the data
            loadCanadianData();
            
            // Create the Statistics Canada Census Subdivisions (CSD) layer
            const statcanCSDLayer = new FeatureLayer({
                url: `${STATCAN_BASE_URL}/9`, // CSD layer (Census Subdivisions)
                title: "Statistics Canada Census Subdivisions",
                renderer: new SimpleRenderer({
                    symbol: new SimpleFillSymbol({
                        color: [34, 139, 34, 0.3], // Forest green with transparency
                        outline: new SimpleLineSymbol({
                            color: [34, 139, 34, 0.8], // Dark green outline
                            width: 1
                        })
                    })
                }),
                outFields: ["*"],
                popupEnabled: false,
                // This is a public service, no authentication needed
                highlightOptions: {
                    color: [50, 205, 50, 0.8], // Lime green highlight
                    fillOpacity: 0.7,
                    haloColor: [50, 205, 50],
                    haloOpacity: 0.7
                }
            });
            
            // Add all layers to the map
            map.add(psapLayer);
            map.add(canadaTownsLayer);
            map.add(statcanCSDLayer);
            map.add(koordinatesLayer);
            map.add(drawLayer);

            // Create tooltip element
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.style.display = 'none';
            document.body.appendChild(tooltip);

            // Reference to layer view for highlighting already declared at the top
            // Using the existing psapLayerView and canadaTownsLayerView variables

            // Centralized function to highlight all selected features
            function highlightSelectedFeatures() {
                console.log('Highlighting selected features:', selectedFeatures.length);
                
                // Clear existing highlights first
                highlightSelections.forEach(highlight => {
                    if (highlight && highlight.remove) highlight.remove();
                });
                highlightSelections = [];
                
                if (selectedFeatures.length === 0) {
                    console.log('No features to highlight');
                    return;
                }
                
                // Apply highlights to all selected features based on which layer they belong to
                selectedFeatures.forEach(feature => {
                    try {
                        // Check which layer the feature belongs to
                        const isPsapFeature = feature.layer === psapLayer;
                        
                        if (isPsapFeature && psapLayerView) {
                            const highlight = psapLayerView.highlight(feature);
                            highlightSelections.push(highlight);
                            console.log('Added PSAP highlight');
                        } else if (!isPsapFeature && canadaTownsLayerView) {
                            const highlight = canadaTownsLayerView.highlight(feature);
                            highlightSelections.push(highlight);
                            console.log('Added Canadian Towns highlight');
                        }
                    } catch (error) {
                        console.error('Error highlighting feature:', error);
                    }
                });
            }

            // Helper function to get consistent feature ID
            function getFeatureId(feature) {
                if (!feature || !feature.attributes) {
                    console.warn('Invalid feature object in getFeatureId:', feature);
                    return Math.random().toString(36).substr(2, 9); // Return random ID as fallback
                }
                
                // Try common ID fields
                const id = feature.attributes.ogc_fid ||
                          feature.attributes.OBJECTID || 
                          feature.attributes.FID ||
                          feature.attributes.objectid ||
                          feature.attributes.OBJECTID_1 ||
                          feature.attributes.fid;
                
                // If no ID field found, create a hash of the attributes
                if (id === undefined || id === null) {
                    try {
                        return JSON.stringify(feature.attributes);
                    } catch (e) {
                        console.warn('Failed to stringify feature attributes:', e);
                        return Math.random().toString(36).substr(2, 9);
                    }
                }
                
                return id;
            }

            // Helper function to get PSAP name from attributes
            function getPsapName(attributes) {
                return attributes.psap_name || attributes.name || 'Unknown PSAP';
            }
            
            // Helper function to get town name from attributes
            function getTownName(attributes) {
                // For debugging - log all attributes to see what's available
                console.log('Canadian Town attributes:', attributes);
                
                // Try specific field names that should exist in the Canadian Towns layer
                if (attributes.NAME) {
                    return attributes.NAME;
                }
                
                if (attributes.name) {
                    return attributes.name;
                }
                
                if (attributes.TOWN_NAME) {
                    return attributes.TOWN_NAME;
                }
                
                // Prioritize fields with 'name', 'town', or 'city' in them
                const nameFields = Object.keys(attributes).filter(key => 
                    key.toLowerCase().includes('name') || 
                    key.toLowerCase().includes('town') || 
                    key.toLowerCase().includes('city')
                );
                
                for (const field of nameFields) {
                    if (attributes[field] && typeof attributes[field] === 'string' && attributes[field].trim() !== '') {
                        return attributes[field];
                    }
                }
                
                // If no name found, combine the ID and any other useful information
                return `Town ID: ${attributes.OBJECTID || attributes.FID || 'Unknown'}`;
            }
            
            // Helper function to get Koordinates feature name from attributes
            function getKoordinatesName(attributes) {
                console.log('Koordinates feature attributes:', attributes);
                
                // Try common name fields
                if (attributes.name) {
                    return attributes.name;
                }
                if (attributes.NAME) {
                    return attributes.NAME;
                }
                if (attributes.title) {
                    return attributes.title;
                }
                if (attributes.label) {
                    return attributes.label;
                }
                
                // Look for any field containing 'name'
                const nameFields = Object.keys(attributes).filter(key => 
                    key.toLowerCase().includes('name')
                );
                
                for (const field of nameFields) {
                    if (attributes[field] && typeof attributes[field] === 'string' && attributes[field].trim() !== '') {
                        return attributes[field];
                    }
                }
                
                // If no name found, use the first string attribute or create a generic name
                const stringFields = Object.keys(attributes).filter(key => 
                    typeof attributes[key] === 'string' && attributes[key].trim() !== ''
                );
                
                if (stringFields.length > 0) {
                    return attributes[stringFields[0]];
                }
                
                return 'Koordinates Feature';
            }
            
            // Helper function to get Statistics Canada CSD feature name from attributes
            function getStatCanCSDName(attributes) {
                console.log('StatCan CSD feature attributes:', attributes);
                
                // Try common name fields for Census Subdivisions
                if (attributes.CSDNAME) {
                    return attributes.CSDNAME;
                }
                if (attributes.CSD_NAME) {
                    return attributes.CSD_NAME;
                }
                if (attributes.name) {
                    return attributes.name;
                }
                if (attributes.NAME) {
                    return attributes.NAME;
                }
                
                // Look for fields containing 'name'
                const nameFields = Object.keys(attributes).filter(key => 
                    key.toLowerCase().includes('name')
                );
                
                for (const field of nameFields) {
                    if (attributes[field] && typeof attributes[field] === 'string' && attributes[field].trim() !== '') {
                        return attributes[field];
                    }
                }
                
                // Use ID if available
                if (attributes.CSDUID) {
                    return `CSD ${attributes.CSDUID}`;
                }
                if (attributes.CSD_UID) {
                    return `CSD ${attributes.CSD_UID}`;
                }
                
                return 'StatCan Census Subdivision';
            }

            // Helper function to update selection panel - implementation from Canada app
            function updateSelectionPanel() {
                console.log('Updating selection panel with', selectedFeatures.length, 'features');
                
                // Update count display and button text
                selectionCount.textContent = selectedFeatures.length;
                downloadBtn.textContent = `üì• Download Selected (${selectedFeatures.length})`;
                
                // Count how many features of each type
                const psapCount = selectedFeatures.filter(f => f.layer === psapLayer).length;
                const townCount = selectedFeatures.filter(f => f.layer === canadaTownsLayer).length;
                const statcanCount = selectedFeatures.filter(f => f.layer === statcanCSDLayer).length;
                const koordinatesCount = selectedFeatures.filter(f => f.layer === koordinatesLayer).length;
                
                // Create an appropriate header text based on what's selected
                const headerTextElement = document.getElementById('selectionHeaderText');
                const totalFeatureTypes = [psapCount > 0, townCount > 0, statcanCount > 0, koordinatesCount > 0].filter(Boolean).length;
                
                if (totalFeatureTypes > 1) {
                    const parts = [];
                    if (psapCount > 0) parts.push(`${psapCount} PSAPs`);
                    if (townCount > 0) parts.push(`${townCount} Towns`);
                    if (statcanCount > 0) parts.push(`${statcanCount} StatCan`);
                    if (koordinatesCount > 0) parts.push(`${koordinatesCount} Koordinates`);
                    headerTextElement.textContent = `Selected Features (${parts.join(', ')})`;
                } else if (psapCount > 0) {
                    headerTextElement.textContent = `Selected PSAPs`;
                } else if (townCount > 0) {
                    headerTextElement.textContent = `Selected Towns`;
                } else if (statcanCount > 0) {
                    headerTextElement.textContent = `Selected Census Subdivisions`;
                } else if (koordinatesCount > 0) {
                    headerTextElement.textContent = `Selected Koordinates Features`;
                } else {
                    headerTextElement.textContent = `Selected Features`;
                }
                
                // Show/hide panel and update button states
                if (selectedFeatures.length > 0) {
                    selectionPanel.style.display = 'block';
                    downloadBtn.disabled = false;
                    clearAllBtn.disabled = false;
                } else {
                    selectionPanel.style.display = 'none';
                    downloadBtn.disabled = true;
                    clearAllBtn.disabled = true;
                }
                
                // Clear and rebuild selection list - IMPORTANT: Do this in one place only
                selectionList.innerHTML = '';
                
                // Add each selected feature to the panel
                selectedFeatures.forEach((feature, index) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'selected-item';
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'item-name';
                    
                    // Get appropriate name based on which layer the feature belongs to
                    const isPsapFeature = feature.layer === psapLayer;
                    const isCanadaFeature = feature.layer === canadaTownsLayer;
                    const isStatCanFeature = feature.layer === statcanCSDLayer;
                    const isKoordinatesFeature = feature.layer === koordinatesLayer;
                    
                    if (isPsapFeature) {
                        nameSpan.textContent = getPsapName(feature.attributes);
                    } else if (isCanadaFeature) {
                        nameSpan.textContent = getTownName(feature.attributes);
                    } else if (isStatCanFeature) {
                        nameSpan.textContent = getStatCanCSDName(feature.attributes);
                    } else if (isKoordinatesFeature) {
                        nameSpan.textContent = getKoordinatesName(feature.attributes);
                    } else {
                        nameSpan.textContent = 'Unknown Feature';
                    }
                    
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-btn';
                    removeBtn.textContent = '√ó';
                    removeBtn.title = 'Remove from selection';
                    removeBtn.onclick = () => removeFromSelection(index);
                    
                    itemDiv.appendChild(nameSpan);
                    itemDiv.appendChild(removeBtn);
                    selectionList.appendChild(itemDiv);
                });
            }
            
            // Helper function to remove item from selection - from Canada app
            function removeFromSelection(index) {
                if (index >= 0 && index < selectedFeatures.length) {
                    // Get the feature to show in status message
                    const feature = selectedFeatures[index];
                    const isPsapFeature = feature.layer === psapLayer;
                    const featureName = isPsapFeature ? 
                        getPsapName(feature.attributes) : 
                        getTownName(feature.attributes);
                    
                    // Remove highlight
                    if (highlightSelections[index]) {
                        highlightSelections[index].remove();
                    }
                    
                    // Remove from arrays
                    selectedFeatures.splice(index, 1);
                    highlightSelections.splice(index, 1);
                    
                    // Update UI
                    updateSelectionPanel();
                    status.textContent = `Removed ${featureName} from selection`;
                }
            }

            // Helper function to clear all selections
            function clearAllSelections() {
                console.log('Clearing all selections');
                
                // Remove all highlights
                highlightSelections.forEach(highlight => {
                    if (highlight && highlight.remove) {
                        try {
                            highlight.remove();
                        } catch (e) {
                            console.error('Error removing highlight:', e);
                        }
                    }
                });

                selectedFeatures = [];
                highlightSelections = [];
                
                // Clear PSAP layer highlights if available
                if (psapLayerView && psapLayerView.highlight) {
                    try {
                        psapLayerView.highlight();
                    } catch (e) {
                        console.error('Error clearing PSAP highlights:', e);
                    }
                }
                
                // Clear Canadian Towns layer highlights if available
                if (canadaTownsLayerView && canadaTownsLayerView.highlight) {
                    try {
                        canadaTownsLayerView.highlight();
                    } catch (e) {
                        console.error('Error clearing Canadian Towns highlights:', e);
                    }
                }
                
                updateSelectionPanel();
                updateStatus();
                
                // Update button state
                clearAllBtn.disabled = true;
                downloadBtn.disabled = true;
                downloadBtn.textContent = 'üì• Download Selected (0)';
            }

            // Helper function to update status message
            function updateStatus() {
                if (selectedFeatures.length === 0) {
                    if (activeLayer === 'psap') {
                        status.textContent = 'Click to select PSAPs. Hold Ctrl/Cmd for multiple selection.';
                    } else if (activeLayer === 'canada') {
                        status.textContent = 'Click to select Canadian towns. Hold Ctrl/Cmd for multiple selection.';
                    } else if (activeLayer === 'statcan') {
                        status.textContent = 'Click to select Census Subdivisions. Hold Ctrl/Cmd for multiple selection.';
                    } else if (activeLayer === 'koordinates') {
                        status.textContent = 'Click to select Koordinates features. Hold Ctrl/Cmd for multiple selection.';
                    }
                } else {
                    if (activeLayer === 'psap') {
                        status.textContent = `${selectedFeatures.length} PSAP${selectedFeatures.length > 1 ? 's' : ''} selected. Use Ctrl/Cmd+click to add more.`;
                    } else if (activeLayer === 'canada') {
                        status.textContent = `${selectedFeatures.length} town${selectedFeatures.length > 1 ? 's' : ''} selected. Use Ctrl/Cmd+click to add more.`;
                    } else if (activeLayer === 'statcan') {
                        status.textContent = `${selectedFeatures.length} subdivision${selectedFeatures.length > 1 ? 's' : ''} selected. Use Ctrl/Cmd+click to add more.`;
                    } else if (activeLayer === 'koordinates') {
                        status.textContent = `${selectedFeatures.length} feature${selectedFeatures.length > 1 ? 's' : ''} selected. Use Ctrl/Cmd+click to add more.`;
                    }
                }
            }

            // Functions for Koordinates API integration
            async function queryKoordinatesData(x, y, maxResults = 3, radius = 10000) {
                if (KOORDINATES_API_KEY === '[api_token]') {
                    console.warn('Koordinates API key not configured');
                    return [];
                }

                const url = `${KOORDINATES_BASE_URL}?key=${KOORDINATES_API_KEY}&layer=${KOORDINATES_LAYER_ID}&x=${x}&y=${y}&max_results=${maxResults}&radius=${radius}&geometry=true&with_field_names=true`;
                
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    return data.vectorQuery?.layers?.[0]?.features || [];
                } catch (error) {
                    console.error('Error querying Koordinates data:', error);
                    return [];
                }
            }

            function createKoordinatesGraphic(feature) {
                // Convert Koordinates geometry to ArcGIS geometry
                let geometry = null;
                
                if (feature.geometry) {
                    if (feature.geometry.type === 'Polygon') {
                        geometry = {
                            type: "polygon",
                            rings: feature.geometry.coordinates,
                            spatialReference: { wkid: 4326 }
                        };
                    } else if (feature.geometry.type === 'Point') {
                        geometry = {
                            type: "point",
                            x: feature.geometry.coordinates[0],
                            y: feature.geometry.coordinates[1],
                            spatialReference: { wkid: 4326 }
                        };
                    } else if (feature.geometry.type === 'MultiPolygon') {
                        // Flatten MultiPolygon to Polygon with multiple rings
                        const rings = [];
                        feature.geometry.coordinates.forEach(polygon => {
                            polygon.forEach(ring => rings.push(ring));
                        });
                        geometry = {
                            type: "polygon",
                            rings: rings,
                            spatialReference: { wkid: 4326 }
                        };
                    }
                }

                if (!geometry) return null;

                // Create symbol based on geometry type
                let symbol;
                if (geometry.type === 'polygon') {
                    symbol = new SimpleFillSymbol({
                        color: [255, 165, 0, 0.4], // Orange with transparency
                        outline: new SimpleLineSymbol({
                            color: [255, 140, 0, 0.8], // Dark orange outline
                            width: 2
                        })
                    });
                } else if (geometry.type === 'point') {
                    symbol = {
                        type: "simple-marker",
                        color: [255, 165, 0, 0.8],
                        outline: {
                            color: [255, 140, 0],
                            width: 2
                        },
                        size: 8
                    };
                }

                return new Graphic({
                    geometry: geometry,
                    symbol: symbol,
                    attributes: feature.properties || {},
                    layer: koordinatesLayer
                });
            }

            async function loadKoordinatesDataInView() {
                // Clear existing Koordinates graphics
                koordinatesLayer.removeAll();

                const extent = view.extent;
                const center = extent.center;
                
                // Query data at the center of the current view
                const features = await queryKoordinatesData(center.x, center.y, 50, 50000);
                
                if (features.length > 0) {
                    const graphics = features.map(createKoordinatesGraphic).filter(g => g !== null);
                    koordinatesLayer.addMany(graphics);
                    console.log(`Loaded ${graphics.length} Koordinates features`);
                    status.textContent = `Loaded ${graphics.length} Koordinates features`;
                }
            }

            // Toggle selection panel
            panelToggle.addEventListener('click', function() {
                const content = document.querySelector('.panel-content');
                const footer = document.querySelector('.panel-footer');
                
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    footer.style.display = 'block';
                    panelToggle.textContent = '‚àí';
                } else {
                    content.style.display = 'none';
                    footer.style.display = 'none';
                    panelToggle.textContent = '+';
                }
            });

            // Clear all selections
            clearAllBtn.addEventListener('click', clearAllSelections);

            // Search functionality
            searchInput.addEventListener('keyup', function(e) {
                if (e.key === 'Enter') {
                    performSearch();
                }
            });
            
            searchButton.addEventListener('click', performSearch);
            
            // Handle clicks on search result buttons
            searchResults.addEventListener('click', function(e) {
                const zoomBtn = e.target.closest('.zoom-to-feature');
                const selectBtn = e.target.closest('.select-feature');
                
                if (!(zoomBtn || selectBtn)) return;
                
                e.stopPropagation();
                e.preventDefault();
                
                const featureItem = (zoomBtn || selectBtn).closest('.search-result-item');
                if (!featureItem || !featureItem.featureData) return;
                
                const featureData = featureItem.featureData;
                console.log('Search result clicked:', featureData);
                
                if (zoomBtn) {
                    // Zoom to the feature
                    try {
                        if (featureData.geometry) {
                            view.goTo({
                                target: featureData.geometry,
                                zoom: 12
                            });
                        } else if (featureData.extent) {
                            view.goTo({
                                target: featureData.extent,
                                zoom: 12
                            });
                        } else if (featureData.attributes && featureData.attributes.Shape) {
                            view.goTo({
                                target: featureData.attributes.Shape,
                                zoom: 12
                            });
                        }
                        // Don't hide results when just zooming
                        return;
                    } catch (error) {
                        console.error('Error zooming to feature:', error);
                    }
                }
                
                if (selectBtn) {
                    try {
                        // Make sure the feature has the required properties
                        const featureToSelect = {
                            attributes: featureData.attributes || {},
                            geometry: featureData.geometry,
                            layer: featureData.layerType === 'psap' ? psapLayer : canadaTownsLayer
                        };
                        
                        // Select the feature
                        selectFeature(featureToSelect);
                        
                        // Highlight the feature
                        try {
                            if (featureData.layerType === 'psap' && psapLayerView) {
                                const highlight = psapLayerView.highlight(featureToSelect);
                                highlightSelections.push(highlight);
                            } else if (featureData.layerType === 'canada' && canadaTownsLayerView) {
                                const highlight = canadaTownsLayerView.highlight(featureToSelect);
                                highlightSelections.push(highlight);
                            }
                        } catch (highlightError) {
                            console.error('Error highlighting feature:', highlightError);
                        }
                        
                        // Hide search results after selection
                        searchResults.style.display = 'none';
                        
                    } catch (error) {
                        console.error('Error selecting feature:', error);
                        status.textContent = 'Error selecting feature: ' + (error.message || 'Unknown error');
                    }
                }
            });
            
            function performSearch() {
                const searchTerm = searchInput.value.trim();
                if (searchTerm.length < 2) return;
                
                // Clear previous search results
                searchResults.innerHTML = '';
                
                // Search the currently focused layer, but also support searching all layers
                if (activeLayer === 'psap') {
                    try {
                        if (!psapLayer) {
                            throw new Error('PSAP layer not initialized');
                        }
                        
                        // Ensure the layer is loaded
                        if (!psapLayer.loaded) {
                            console.log('PSAP layer not loaded yet, waiting...');
                            return psapLayer.load()
                                .then(() => {
                                    console.log('PSAP layer loaded, retrying search...');
                                    return performSearch(); // Retry the search now that the layer is loaded
                                });
                        }
                        
                        const psapQuery = psapLayer.createQuery();
                        psapQuery.where = `UPPER(psap_name) LIKE UPPER('%${searchTerm.replace(/'/g, "''")}%') OR UPPER(account_id) LIKE UPPER('%${searchTerm.replace(/'/g, "''")}%') OR UPPER(NAME) LIKE UPPER('%${searchTerm.replace(/'/g, "''")}%')`;
                        psapQuery.outFields = ["*"];
                        psapQuery.returnGeometry = true;
                        
                        console.log('Executing PSAP query with where clause:', psapQuery.where);
                        
                        return psapLayer.queryFeatures(psapQuery)
                            .then(psapResults => {
                                console.log('PSAP search results:', psapResults);
                                if (!psapResults || !psapResults.features || psapResults.features.length === 0) {
                                    searchResults.innerHTML = `
                                        <div class="search-result-item">
                                            No results found for "${searchTerm}" in US PSAPs layer - do you have the right layer selected in the top right?
                                        </div>`;
                                    searchResults.style.display = 'block';
                                    return;
                                }
                                
                                // Process features to ensure they have the required structure
                                const processedFeatures = psapResults.features.map(feature => {
                                    // Ensure the feature has attributes
                                    if (!feature.attributes) {
                                        feature.attributes = {};
                                    }
                                    
                                    // Add layer information
                                    feature.layerType = 'psap';
                                    feature.layerName = 'PSAP 911 Service Area';
                                    
                                    // Ensure we have a name attribute
                                    if (!feature.attributes.name && feature.attributes.PSAP_NAME) {
                                        feature.attributes.name = feature.attributes.PSAP_NAME;
                                    } else if (!feature.attributes.name && feature.attributes.NAME) {
                                        feature.attributes.name = feature.attributes.NAME;
                                    } else if (!feature.attributes.name && feature.attributes.STATE) {
                                        feature.attributes.name = feature.attributes.STATE;
                                    } else if (!feature.attributes.name && feature.attributes.COUNTY) {
                                        feature.attributes.name = feature.attributes.COUNTY;
                                    } else if (!feature.attributes.name && feature.attributes.CITY) {
                                        feature.attributes.name = feature.attributes.CITY;
                                    } else if (!feature.attributes.name) {
                                        feature.attributes.name = 'Unnamed PSAP';
                                    }
                                    
                                    return feature;
                                });
                                
                                console.log('Processed PSAP features:', processedFeatures);
                                displaySearchResults(processedFeatures);
                            });
                    } catch (error) {
                        console.error('Error in PSAP search:', error);
                        searchResults.innerHTML = `
                            <div class="search-result-item">
                                <strong>Error searching PSAPs:</strong><br>
                                ${error.message || 'Unknown error occurred'}
                            </div>`;
                        searchResults.style.display = 'block';
                    }
                } else if (activeLayer === 'canada') {
                    // Canadian Towns search
                    return searchCanadianTowns(searchTerm);
                } else if (activeLayer === 'statcan') {
                    // Statistics Canada search
                    return searchStatCanLayer(searchTerm);
                } else if (activeLayer === 'koordinates') {
                    // Koordinates search
                    return searchKoordinatesLayer(searchTerm);
                } else {
                    // Default fallback - search all layers
                    return searchAllLayers(searchTerm);
                }
            }
            
            // Separate function for Canadian Towns search
            async function searchCanadianTowns(searchTerm) {
                try {
                    if (!canadaTownsLayer) {
                        throw new Error('Canadian Towns layer not initialized');
                    }

                    // Ensure the layer is loaded
                    if (!canadaTownsLayer.loaded) {
                        console.log('Canadian Towns layer not loaded yet, waiting...');
                        await canadaTownsLayer.load();
                        console.log('Canadian Towns layer loaded, retrying search...');
                    }

                    console.log('Searching Canadian Towns layer for:', searchTerm);
                    
                    // Create query specifically for CSDNAME field
                    const canadaQuery = canadaTownsLayer.createQuery();
                    
                    // Search only in the CSDNAME field
                    canadaQuery.where = `UPPER(CSDNAME) LIKE UPPER('%${searchTerm.replace(/'/g, "''")}%')`;
                    canadaQuery.outFields = ["*", "CSDNAME"];
                    canadaQuery.returnGeometry = true;
                    canadaQuery.returnDistinctValues = true;
                    
                    console.log('Executing Canadian Towns query on CSDNAME field:', searchTerm);
                    
                    const canadaResults = await canadaTownsLayer.queryFeatures(canadaQuery);
                    console.log('Canadian Towns search results:', canadaResults);
                    
                    if (!canadaResults || !canadaResults.features || canadaResults.features.length === 0) {
                        searchResults.innerHTML = `
                            <div class="search-result-item">
                                No results found for "${searchTerm}" in Canadian Towns layer
                            </div>`;
                        searchResults.style.display = 'block';
                        return;
                    }
                    
                    // Process features to ensure they have the required structure
                    const processedFeatures = canadaResults.features.map(feature => {
                        // Ensure the feature has attributes
                        if (!feature.attributes) {
                            feature.attributes = {};
                        }
                        
                        // Add layer information
                        feature.layerType = 'canada';
                        feature.layerName = 'Canadian Town';
                        
                        // Find a suitable name field
                        const nameField = Object.keys(feature.attributes).find(key => 
                            /(name|town|city|municipal|nom|ville|community|place)/i.test(key)
                        );
                        
                        // Set a name if we don't have one
                        if (!feature.attributes.name && nameField) {
                            feature.attributes.name = feature.attributes[nameField];
                        } else if (!feature.attributes.name) {
                            feature.attributes.name = 'Unnamed Location';
                        }
                        
                        return feature;
                    });
                    
                    console.log('Processed Canadian features:', processedFeatures);
                    displaySearchResults(processedFeatures);
                } catch (error) {
                    console.error('Error in Canadian Towns search:', error);
                    searchResults.innerHTML = `
                        <div class="search-result-item">
                            <strong>Error searching Canadian Towns:</strong><br>
                            ${error.message || 'Unknown error occurred'}
                        </div>`;
                    searchResults.style.display = 'block';
                    throw error;
                }
            }
            
            // New function for Statistics Canada search
            async function searchStatCanLayer(searchTerm) {
                try {
                    if (!statcanCSDLayer) {
                        throw new Error('Statistics Canada layer not initialized');
                    }

                    // Ensure the layer is loaded
                    if (!statcanCSDLayer.loaded) {
                        console.log('StatCan layer not loaded yet, waiting...');
                        await statcanCSDLayer.load();
                        console.log('StatCan layer loaded, retrying search...');
                    }

                    console.log('Searching Statistics Canada layer for:', searchTerm);
                    
                    // Create query for StatCan CSD layer
                    const statcanQuery = statcanCSDLayer.createQuery();
                    
                    // Search in common name fields for Census Subdivisions
                    statcanQuery.where = `UPPER(CSDNAME) LIKE UPPER('%${searchTerm.replace(/'/g, "''")}%') OR UPPER(NAME) LIKE UPPER('%${searchTerm.replace(/'/g, "''")}%')`;
                    statcanQuery.outFields = ["*"];
                    statcanQuery.returnGeometry = true;
                    
                    console.log('Executing StatCan query:', statcanQuery.where);
                    
                    const statcanResults = await statcanCSDLayer.queryFeatures(statcanQuery);
                    console.log('StatCan search results:', statcanResults);
                    
                    if (!statcanResults || !statcanResults.features || statcanResults.features.length === 0) {
                        searchResults.innerHTML = `
                            <div class="search-result-item">
                                No results found for "${searchTerm}" in Statistics Canada layer
                            </div>`;
                        searchResults.style.display = 'block';
                        return;
                    }
                    
                    // Process features
                    const processedFeatures = statcanResults.features.map(feature => {
                        if (!feature.attributes) {
                            feature.attributes = {};
                        }
                        
                        // Add layer information
                        feature.layerType = 'statcan';
                        feature.layerName = 'StatCan Census Subdivision';
                        
                        // Ensure we have a name
                        if (!feature.attributes.name) {
                            feature.attributes.name = feature.attributes.CSDNAME || feature.attributes.NAME || 'Unnamed Subdivision';
                        }
                        
                        return feature;
                    });
                    
                    console.log('Processed StatCan features:', processedFeatures);
                    displaySearchResults(processedFeatures);
                } catch (error) {
                    console.error('Error in StatCan search:', error);
                    searchResults.innerHTML = `
                        <div class="search-result-item">
                            <strong>Error searching Statistics Canada layer:</strong><br>
                            ${error.message || 'Unknown error occurred'}
                        </div>`;
                    searchResults.style.display = 'block';
                    throw error;
                }
            }
            
            // New function for Koordinates search
            async function searchKoordinatesLayer(searchTerm) {
                try {
                    if (KOORDINATES_API_KEY === '[api_token]') {
                        searchResults.innerHTML = `
                            <div class="search-result-item">
                                <strong>Koordinates API key not configured</strong><br>
                                Please set your API key to search Koordinates data.
                            </div>`;
                        searchResults.style.display = 'block';
                        return;
                    }

                    console.log('Searching Koordinates layer for:', searchTerm);
                    
                    // For Koordinates, we'll search the currently loaded features
                    const loadedFeatures = koordinatesLayer.graphics.toArray();
                    
                    if (loadedFeatures.length === 0) {
                        searchResults.innerHTML = `
                            <div class="search-result-item">
                                No Koordinates data loaded. Click "Load Koordinates Data" first.
                            </div>`;
                        searchResults.style.display = 'block';
                        return;
                    }
                    
                    // Filter features by search term
                    const matchingFeatures = loadedFeatures.filter(graphic => {
                        const attrs = graphic.attributes || {};
                        
                        // Search in all string attributes
                        return Object.values(attrs).some(value => {
                            if (typeof value === 'string') {
                                return value.toLowerCase().includes(searchTerm.toLowerCase());
                            }
                            return false;
                        });
                    });
                    
                    if (matchingFeatures.length === 0) {
                        searchResults.innerHTML = `
                            <div class="search-result-item">
                                No results found for "${searchTerm}" in loaded Koordinates data
                            </div>`;
                        searchResults.style.display = 'block';
                        return;
                    }
                    
                    // Convert graphics to features for display
                    const processedFeatures = matchingFeatures.map(graphic => ({
                        geometry: graphic.geometry,
                        attributes: graphic.attributes,
                        layerType: 'koordinates',
                        layerName: 'Koordinates Feature'
                    }));
                    
                    console.log('Processed Koordinates features:', processedFeatures);
                    displaySearchResults(processedFeatures);
                } catch (error) {
                    console.error('Error in Koordinates search:', error);
                    searchResults.innerHTML = `
                        <div class="search-result-item">
                            <strong>Error searching Koordinates data:</strong><br>
                            ${error.message || 'Unknown error occurred'}
                        </div>`;
                    searchResults.style.display = 'block';
                }
            }
            
            // New function to search all layers
            async function searchAllLayers(searchTerm) {
                try {
                    console.log('Searching all layers for:', searchTerm);
                    
                    // Search all layers in parallel
                    const searchPromises = [
                        searchPSAPLayer(searchTerm),
                        searchCanadianTowns(searchTerm), 
                        searchStatCanLayer(searchTerm),
                        searchKoordinatesLayer(searchTerm)
                    ];
                    
                    // Wait for all searches to complete
                    await Promise.allSettled(searchPromises);
                    
                } catch (error) {
                    console.error('Error in multi-layer search:', error);
                    searchResults.innerHTML = `
                        <div class="search-result-item">
                            <strong>Error searching layers:</strong><br>
                            ${error.message || 'Unknown error occurred'}
                        </div>`;
                    searchResults.style.display = 'block';
                }
            }
            
            // Extract PSAP search into separate function
            async function searchPSAPLayer(searchTerm) {
                try {
                    if (!psapLayer) {
                        throw new Error('PSAP layer not initialized');
                    }
                    
                    // Ensure the layer is loaded
                    if (!psapLayer.loaded) {
                        console.log('PSAP layer not loaded yet, waiting...');
                        await psapLayer.load();
                        console.log('PSAP layer loaded, retrying search...');
                    }
                    
                    const psapQuery = psapLayer.createQuery();
                    psapQuery.where = `UPPER(NAME) LIKE UPPER('%${searchTerm.replace(/'/g, "''")}%') OR UPPER(STATE_NAME) LIKE UPPER('%${searchTerm.replace(/'/g, "''")}%')`;
                    psapQuery.outFields = ["*"];
                    psapQuery.returnGeometry = true;
                    
                    console.log('Executing PSAP query with where clause:', psapQuery.where);
                    
                    const psapResults = await psapLayer.queryFeatures(psapQuery);
                    console.log('PSAP search results:', psapResults);
                    
                    if (!psapResults || !psapResults.features || psapResults.features.length === 0) {
                        return [];
                    }
                    
                    // Process features to ensure they have the required structure
                    const processedFeatures = psapResults.features.map(feature => {
                        if (!feature.attributes) {
                            feature.attributes = {};
                        }
                        
                        // Add layer information
                        feature.layerType = 'psap';
                        feature.layerName = 'PSAP';
                        
                        // Ensure we have a name attribute
                        if (!feature.attributes.name && feature.attributes.NAME) {
                            feature.attributes.name = feature.attributes.NAME;
                        } else if (!feature.attributes.name && feature.attributes.STATE_NAME) {
                            feature.attributes.name = feature.attributes.STATE_NAME;
                        } else if (!feature.attributes.name) {
                            feature.attributes.name = 'Unnamed State';
                        }
                        
                        return feature;
                    });
                    
                    console.log('Processed PSAP features:', processedFeatures);
                    if (activeLayer === 'psap') {
                        displaySearchResults(processedFeatures);
                    }
                    return processedFeatures;
                } catch (error) {
                    console.error('Error in PSAP search:', error);
                    if (activeLayer === 'psap') {
                        searchResults.innerHTML = `
                            <div class="search-result-item">
                                <strong>Error searching states:</strong><br>
                                ${error.message || 'Unknown error occurred'}
                            </div>`;
                        searchResults.style.display = 'block';
                    }
                    throw error;
                }
            }
            
            // Update the layer switch button text
            function updateLayerSwitchText() {
                const button = document.getElementById('layerSwitchBtn');
                if (button) {
                    if (activeLayer === 'psap') {
                        button.textContent = 'Focus: US PSAPs';
                    } else if (activeLayer === 'canada') {
                        button.textContent = 'Focus: Canadian Provinces';
                    } else if (activeLayer === 'statcan') {
                        button.textContent = 'Focus: StatCan Subdivisions';
                    } else if (activeLayer === 'koordinates') {
                        button.textContent = 'Focus: Koordinates Data';
                    }
                }
                
                // Update search placeholder based on active layer
                updateSearchPlaceholder();
            }
            
            // Update search placeholder text based on active layer
            function updateSearchPlaceholder() {
                if (searchInput) {
                    if (activeLayer === 'psap') {
                        searchInput.placeholder = 'Search for a PSAP 911 service area...';
                    } else if (activeLayer === 'canada') {
                        searchInput.placeholder = 'Search for a Canadian province...';
                    } else if (activeLayer === 'statcan') {
                        searchInput.placeholder = 'Search for a census subdivision...';
                    } else if (activeLayer === 'koordinates') {
                        searchInput.placeholder = 'Search Koordinates data...';
                    } else {
                        searchInput.placeholder = 'Search...';
                    }
                }
            }
            
            // Toggle between layers (PSAP -> Canadian Towns -> StatCan -> Koordinates -> PSAP)
            function toggleActiveLayer() {
                try {
                    // Cycle through the layers
                    if (activeLayer === 'psap') {
                        activeLayer = 'canada';
                    } else if (activeLayer === 'canada') {
                        activeLayer = 'statcan';
                    } else if (activeLayer === 'statcan') {
                        activeLayer = 'koordinates';
                    } else {
                        activeLayer = 'psap';
                    }
                    console.log('Toggling active layer to:', activeLayer);
                    
                    // Adjust layer visibility and opacity based on active layer
                    if (psapLayer) {
                        psapLayer.visible = true;
                        psapLayer.opacity = activeLayer === 'psap' ? 1 : 0.3;
                        console.log('PSAP layer - visible:', psapLayer.visible, 'opacity:', psapLayer.opacity);
                    }
                    
                    if (canadaTownsLayer) {
                        canadaTownsLayer.visible = true;
                        canadaTownsLayer.opacity = activeLayer === 'canada' ? 1 : 0.3;
                        console.log('Canada Towns layer - visible:', canadaTownsLayer.visible, 'opacity:', canadaTownsLayer.opacity);
                    }
                    
                    if (statcanCSDLayer) {
                        statcanCSDLayer.visible = true;
                        statcanCSDLayer.opacity = activeLayer === 'statcan' ? 1 : 0.3;
                        console.log('StatCan CSD layer - visible:', statcanCSDLayer.visible, 'opacity:', statcanCSDLayer.opacity);
                    }
                    
                    if (koordinatesLayer) {
                        koordinatesLayer.visible = activeLayer === 'koordinates';
                        koordinatesLayer.opacity = activeLayer === 'koordinates' ? 1 : 0.3;
                        console.log('Koordinates layer - visible:', koordinatesLayer.visible, 'opacity:', koordinatesLayer.opacity);
                        
                        // Load Koordinates data when switching to that layer
                        if (activeLayer === 'koordinates') {
                            loadKoordinatesDataInView();
                        }
                    }
                    
                    // No need to re-initialize popups as both layers are now always visible
                    
                    // Update the button text
                    updateLayerSwitchText();
                    
                    // Update the map view to show the active layer's extent if available
                    if (activeLayer === 'psap' && psapLayer) {
                        zoomToLayerExtent(psapLayer);
                    } else if (activeLayer === 'canada' && canadaTownsLayer) {
                        zoomToLayerExtent(canadaTownsLayer);
                    }
                    
                    // Clear any existing search results when switching layers
                    if (searchResults) {
                        searchResults.innerHTML = '';
                        searchResults.style.display = 'none';
                    }
                    
                    // Update status to show which layer is active
                    if (status) {
                        if (activeLayer === 'psap') {
                            status.textContent = 'PSAP layer active. Click on a PSAP to select it.';
                        } else if (activeLayer === 'canada') {
                            status.textContent = 'Canadian Towns layer active. Click on a town to select it.';
                        } else if (activeLayer === 'statcan') {
                            status.textContent = 'StatCan Census Subdivisions layer active. Click on a subdivision to select it.';
                        } else if (activeLayer === 'koordinates') {
                            status.textContent = 'Koordinates layer active. Click on a feature to select it.';
                        }
                    }
                    
                    // Clear any existing highlights when switching layers
                    if (psapLayerView) {
                        psapLayerView.highlightRemoveAll();
                    }
                    if (canadaTownsLayerView) {
                        canadaTownsLayerView.highlightRemoveAll();
                    }
                    
                    // Clear the selection panel when switching layers
                    selectedFeatures = [];
                    if (updateSelectionPanel) updateSelectionPanel();
                    if (updateStatus) updateStatus();
                    
                    console.log('Switched to', activeLayer === 'psap' ? 'PSAP' : 'Canadian Towns', 'layer');
                    
                } catch (error) {
                    console.error('Error in toggleActiveLayer:', error);
                    if (status) {
                        status.textContent = 'Error switching layers. Please try again.';
                        setTimeout(() => { status.textContent = ''; }, 3000);
                    }
                }
            }
            
            // Initialize the layer switch button
            const layerSwitchBtn = document.getElementById('layerSwitchBtn');
            if (layerSwitchBtn) {
                // Update the button text based on initial active layer
                updateLayerSwitchText();
                
                // Add event listener to the button
                layerSwitchBtn.addEventListener('click', toggleActiveLayer);
            } else {
                console.error('Layer switch button not found');
            }
            
            function displaySearchResults(features) {
                console.log('Displaying search results:', features);
                searchResults.innerHTML = '';
                
                if (features.length === 0) {
                    const searchTerm = searchInput.value.trim();
                    let layerName = 'current layer';
                    if (activeLayer === 'psap') layerName = 'US PSAPs';
                    else if (activeLayer === 'canada') layerName = 'Canadian Towns';
                    else if (activeLayer === 'statcan') layerName = 'Statistics Canada';
                    else if (activeLayer === 'koordinates') layerName = 'Koordinates';
                    
                    searchResults.innerHTML = `
                        <div class="search-result-item">
                            No results found for "${searchTerm}" in ${layerName} layer - do you have the right layer selected in the top right?
                        </div>`;
                    searchResults.style.display = 'block';
                    return;
                }
                
                const resultsCount = document.createElement('div');
                resultsCount.className = 'search-result-count';
                resultsCount.textContent = `Found ${features.length} result${features.length !== 1 ? 's' : ''}`;
                searchResults.appendChild(resultsCount);
                
                // Group results by layer type
                const resultsByLayer = {
                    psap: features.filter(f => f.layerType === 'psap' || f.layer?.id === 'psap-layer'),
                    canada: features.filter(f => f.layerType === 'canada' || f.layer?.id === 'canada-towns'),
                    statcan: features.filter(f => f.layerType === 'statcan'),
                    koordinates: features.filter(f => f.layerType === 'koordinates')
                };
                
                // Display PSAP results
                if (resultsByLayer.psap.length > 0) {
                    const header = document.createElement('div');
                    header.className = 'search-result-header';
                    header.textContent = `US PSAPs (${resultsByLayer.psap.length})`;
                    searchResults.appendChild(header);
                    
                    resultsByLayer.psap.forEach((feature, index) => {
                        const item = createSearchResultItem(feature, 'psap');
                        if (item) {
                            searchResults.appendChild(item);
                        } else {
                            console.error('Failed to create search result item for PSAP feature:', feature);
                        }
                    });
                }
                
                // Display Canadian Towns results
                if (resultsByLayer.canada.length > 0) {
                    const header = document.createElement('div');
                    header.className = 'search-result-header';
                    header.textContent = `Canadian Towns (${resultsByLayer.canada.length})`;
                    searchResults.appendChild(header);
                    
                    resultsByLayer.canada.forEach((feature, index) => {
                        const item = createSearchResultItem(feature, 'canada');
                        if (item) {
                            searchResults.appendChild(item);
                        } else {
                            console.error('Failed to create search result item for Canada feature:', feature);
                        }
                    });
                }
                
                // Display Statistics Canada results
                if (resultsByLayer.statcan.length > 0) {
                    const header = document.createElement('div');
                    header.className = 'search-result-header';
                    header.textContent = `Statistics Canada (${resultsByLayer.statcan.length})`;
                    searchResults.appendChild(header);
                    
                    resultsByLayer.statcan.forEach((feature, index) => {
                        const item = createSearchResultItem(feature, 'statcan');
                        if (item) {
                            searchResults.appendChild(item);
                        } else {
                            console.error('Failed to create search result item for StatCan feature:', feature);
                        }
                    });
                }
                
                // Display Koordinates results
                if (resultsByLayer.koordinates.length > 0) {
                    const header = document.createElement('div');
                    header.className = 'search-result-header';
                    header.textContent = `Koordinates (${resultsByLayer.koordinates.length})`;
                    searchResults.appendChild(header);
                    
                    resultsByLayer.koordinates.forEach((feature, index) => {
                        const item = createSearchResultItem(feature, 'koordinates');
                        if (item) {
                            searchResults.appendChild(item);
                        } else {
                            console.error('Failed to create search result item for Koordinates feature:', feature);
                        }
                    });
                }
                
                searchResults.style.display = 'block';
                
                function createSearchResultItem(feature, layerType) {
                    try {
                        console.log('Creating search result item:', feature, 'Layer type:', layerType);
                        
                        const item = document.createElement('div');
                        item.className = 'search-result-item';
                        
                        // Ensure feature has attributes and geometry
                        if (!feature.attributes) {
                            feature.attributes = {};
                        }
                        
                        // Get the feature's attributes with a fallback to empty object
                        const attrs = feature.attributes || {};
                        
                        // Get the display name
                        let displayName = 'Unnamed Feature';
                        if (attrs.name) {
                            displayName = attrs.name;
                        } else if (attrs.NAME) {
                            displayName = attrs.NAME;
                        } else if (attrs.psap_name) {
                            displayName = attrs.psap_name;
                        } else if (attrs.account_id) {
                            displayName = attrs.account_id;
                        } else if (attrs.town) {
                            displayName = attrs.town;
                        } else if (attrs.city) {
                            displayName = attrs.city;
                        } else if (attrs.municipality) {
                            displayName = attrs.municipality;
                        } else if (attrs.community) {
                            displayName = attrs.community;
                        } else if (attrs.place_name) {
                            displayName = attrs.place_name;
                        }
                        
                        // Create a more informative display with available attributes
                        let details = '';
                        const excludeFields = ['shape', 'objectid', 'globalid', 'geometry', 'name', 'NAME', 'psap_name', 'account_id'];
                        
                        if (attrs) {
                            Object.entries(attrs).forEach(([key, value]) => {
                                // Skip if value is empty or key is in exclude list
                                if (!value || 
                                    excludeFields.some(field => key.toLowerCase().includes(field.toLowerCase()))) {
                                    return;
                                }
                                
                                // Format the value for display
                                let displayValue = value;
                                if (typeof value === 'object') {
                                    displayValue = JSON.stringify(value);
                                } else if (typeof value === 'boolean') {
                                    displayValue = value ? 'Yes' : 'No';
                                } else if (typeof value === 'number') {
                                    // Format numbers with commas for better readability
                                    displayValue = value.toLocaleString();
                                }
                                
                                details += `<div class="search-result-detail"><strong>${key}:</strong> ${displayValue}</div>`;
                            });
                        }
                        
                        // Create a unique ID for this feature
                        const featureId = attrs.OBJECTID || attrs.objectid || attrs.id || 
                                       feature.OBJECTID || feature.objectid || feature.id || 
                                       Math.random().toString(36).substr(2, 9);
                        
                        // Store the feature data on the item element
                        item.dataset.featureId = featureId;
                        item.featureData = feature;
                        
                        // Get display type based on layer
                        let displayType = 'Feature';
                        if (layerType === 'psap') displayType = 'PSAP';
                        else if (layerType === 'canada') displayType = 'Canadian Town';
                        else if (layerType === 'statcan') displayType = 'StatCan CSD';
                        else if (layerType === 'koordinates') displayType = 'Koordinates';
                        
                        // Set the HTML content for the search result item
                        item.innerHTML = `
                            <div class="search-result-header">
                                <span class="search-result-title">${displayName}</span>
                                <span class="search-result-type">${displayType}</span>
                            </div>
                            <div class="search-result-details">
                                ${details || '<div class="no-details">No additional details available</div>'}
                            </div>
                            <div class="search-result-actions">
                                <button class="btn btn-sm btn-primary zoom-to-feature" data-feature-id="${featureId}">
                                    <i class="fas fa-search-location"></i> Zoom to
                                </button>
                                <button class="btn btn-sm btn-success select-feature" data-feature-id="${featureId}">
                                    <i class="fas fa-check"></i> Select
                                </button>
                            </div>
                        `;
                        
                        // Add click handler for the zoom button
                        const zoomBtn = item.querySelector('.zoom-to-feature');
                        if (zoomBtn) {
                            zoomBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                zoomToFeature(feature);
                            });
                        }
                        
                        // Add click handler for the select button
                        const selectBtn = item.querySelector('.select-feature');
                        if (selectBtn) {
                            selectBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                selectFeature(feature);
                            });
                        }
                        
                        return item;
                    } catch (error) {
                        console.error('Error creating search result item:', error);
                        const errorItem = document.createElement('div');
                        errorItem.className = 'search-result-item';
                        errorItem.innerHTML = `
                            <div class="search-result-header">
                                <span class="search-result-title">Error displaying feature</span>
                            </div>
                            <div class="search-result-details">
                                <div class="no-details">${error.message || 'Unknown error occurred'}</div>
                            </div>
                        `;
                        return errorItem;
                    }
                }
                
                // Helper function to zoom to a feature
                function zoomToFeature(feature) {
                    if (!feature || !feature.geometry) return;
                    
                    // Get the geometry's extent
                    const geometryExtent = feature.geometry.extent || 
                                        (feature.geometry.getExtent ? feature.geometry.getExtent() : null);
                    
                    if (geometryExtent) {
                        // Zoom to the feature's extent with some padding
                        view.goTo({
                            target: geometryExtent,
                            padding: 50 // Add some padding around the feature
                        });
                    } else if (feature.geometry.type === 'point' || 
                              feature.geometry.type === 'multipoint') {
                        // For point features, zoom to a fixed level
                        view.goTo({
                            target: feature.geometry,
                            zoom: 12
                        });
                    } else {
                        // For other geometry types, try to fit to the geometry
                        view.goTo({
                            target: feature.geometry
                        });
                    }
                }
                
                // Helper function to zoom to a layer's extent
                function zoomToLayerExtent(layer) {
                    if (!layer || !layer.graphics || layer.graphics.length === 0) {
                        console.log('No graphics in layer to zoom to');
                        return;
                    }
                    
                    try {
                        // Get all graphics from the layer
                        const graphics = layer.graphics.toArray();
                        if (graphics.length === 0) {
                            console.log('No graphics found in layer');
                            return;
                        }
                        
                        // Calculate the combined extent of all graphics
                        let combinedExtent = null;
                        
                        graphics.forEach(graphic => {
                            if (graphic.geometry) {
                                const graphicExtent = graphic.geometry.extent || 
                                                   (graphic.geometry.getExtent ? graphic.geometry.getExtent() : null);
                                
                                if (graphicExtent) {
                                    if (!combinedExtent) {
                                        combinedExtent = graphicExtent.clone();
                                    } else {
                                        combinedExtent.union(graphicExtent);
                                    }
                                }
                            }
                        });
                        
                        if (combinedExtent) {
                            // Zoom to the combined extent with padding
                            view.goTo({
                                target: combinedExtent,
                                padding: 50
                            });
                            console.log('Zoomed to layer extent');
                        } else {
                            console.log('Could not calculate layer extent');
                        }
                    } catch (error) {
                        console.error('Error zooming to layer extent:', error);
                    }
                }
            }
            
            // Create demo PSAP boundaries as final fallback
            function createDemoPSAPBoundaries() {
                console.log('Creating demo PSAP boundaries...');
                
                // Since we're using FeatureLayer, we need to create a new GraphicsLayer for demo data
                const demoPSAPLayer = new GraphicsLayer({
                    title: "Demo PSAP Boundaries",
                    visible: true,
                    opacity: 1.0
                });
                
                // Add the demo layer to the map
                map.add(demoPSAPLayer);
                
                // Create realistic PSAP boundary polygons
                const demoPSAPs = [
                    {
                        geometry: {
                            type: "polygon",
                            rings: [[
                                [-74.0, 40.7], [-73.9, 40.7], [-73.9, 40.8], [-74.0, 40.8], [-74.0, 40.7]
                            ]]
                        },
                        attributes: {
                            name: "New York City PSAP",
                            psap_name: "NYC Emergency Services",
                            state: "NY",
                            county: "New York",
                            city: "New York",
                            telephone: "911"
                        }
                    },
                    {
                        geometry: {
                            type: "polygon",
                            rings: [[
                                [-87.6, 41.8], [-87.5, 41.8], [-87.5, 41.9], [-87.6, 41.9], [-87.6, 41.8]
                            ]]
                        },
                        attributes: {
                            name: "Chicago PSAP",
                            psap_name: "Chicago Emergency Services",
                            state: "IL",
                            county: "Cook",
                            city: "Chicago",
                            telephone: "911"
                        }
                    },
                    {
                        geometry: {
                            type: "polygon",
                            rings: [[
                                [-118.3, 34.0], [-118.2, 34.0], [-118.2, 34.1], [-118.3, 34.1], [-118.3, 34.0]
                            ]]
                        },
                        attributes: {
                            name: "Los Angeles PSAP",
                            psap_name: "LA Emergency Services",
                            state: "CA",
                            county: "Los Angeles",
                            city: "Los Angeles",
                            telephone: "911"
                        }
                    }
                ];
                
                demoPSAPs.forEach((demoPSAP, index) => {
                    const graphic = new Graphic({
                        geometry: demoPSAP.geometry,
                        symbol: new SimpleFillSymbol({
                            color: [255, 243, 0, 0.3],
                            outline: new SimpleLineSymbol({
                                color: [255, 243, 0, 0.8],
                                width: 1
                            })
                        }),
                        attributes: demoPSAP.attributes
                    });
                    demoPSAPLayer.add(graphic);
                });
                
                console.log(`Created ${demoPSAPs.length} demo PSAP boundaries`);
            }
            
            // Hide search results when clicking elsewhere
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.search-container')) {
                    searchResults.style.display = 'none';
                }
            });

            // Select a feature programmatically (used by search)
            function selectFeature(feature) {
                console.log('selectFeature called with:', feature);
                
                if (!multiSelectMode && selectedFeatures.length > 0) {
                    clearAllSelections();
                }
                
                // Check if already selected using a more robust comparison
                const existingIndex = selectedFeatures.findIndex(f => {
                    // If features have OBJECTID, compare those
                    if (f.attributes && feature.attributes && 
                        f.attributes.OBJECTID !== undefined && 
                        feature.attributes.OBJECTID !== undefined) {
                        return f.attributes.OBJECTID === feature.attributes.OBJECTID;
                    }
                    // If features have objectid, compare those
                    if (f.attributes && feature.attributes && 
                        f.attributes.objectid !== undefined && 
                        feature.attributes.objectid !== undefined) {
                        return f.attributes.objectid === feature.attributes.objectid;
                    }
                    // If features have a geometry, compare the geometry
                    if (f.geometry && feature.geometry) {
                        return f.geometry === feature.geometry;
                    }
                    // Fallback to strict equality
                    return f === feature;
                });
                
                if (existingIndex >= 0) {
                    console.log('Feature already selected');
                    return;
                }
                
                try {
                    // Add to selection
                    selectedFeatures.push(feature);
                    console.log('Added feature to selection. Total selected:', selectedFeatures.length);
                    
                    // Update the UI
                    updateSelectionPanel();
                    updateStatus();
                    
                    // Enable the download and clear buttons
                    downloadBtn.disabled = false;
                    clearAllBtn.disabled = false;
                    
                } catch (error) {
                    console.error('Error in selectFeature:', error);
                    status.textContent = 'Error selecting feature: ' + (error.message || 'Unknown error');
                }
            }
            
            // Hide tooltip when leaving map area
            view.on("pointer-leave", function() {
                tooltip.style.display = 'none';
            });
            
            // Show tooltip with feature name on hover for both layers
            view.on("pointer-move", function(event) {
                view.hitTest(event).then(function(response) {
                    // Check for PSAP layer feature
                    const psapResult = response.results.find(result => 
                        result.graphic && result.graphic.layer === psapLayer
                    );
                    
                    // Check for Canada Towns layer feature
                    const canadaResult = response.results.find(result => 
                        result.graphic && result.graphic.layer === canadaTownsLayer
                    );
                    
                    // First try the focused layer, then the other
                    let hoverResult = null;
                    if (activeLayer === 'psap') {
                        hoverResult = psapResult || canadaResult;
                    } else {
                        hoverResult = canadaResult || psapResult;
                    }
                    
                    // Show tooltip if we found a feature
                    if (hoverResult) {
                        const feature = hoverResult.graphic;
                        let featureName = '';
                        
                        // Determine which layer the feature belongs to and create appropriate tooltip content
                        if (feature.layer === psapLayer) {
                            // For PSAP layer, get the PSAP name and format tooltip
                            featureName = getPsapName(feature.attributes);
                            tooltip.innerHTML = `<strong>${featureName}</strong>`;
                            
                            // Add additional PSAP info if available
                            if (feature.attributes.state) {
                                tooltip.innerHTML += `<br>State: ${feature.attributes.state}`;
                            }
                        } else {
                            // For Canadian Towns layer, get town name and format tooltip with more details
                            featureName = getTownName(feature.attributes);
                            tooltip.innerHTML = `<strong>${featureName}</strong>`;
                            
                            // Add additional town info if available
                            const attrs = feature.attributes;
                            if (attrs.PROVINCE) {
                                tooltip.innerHTML += `<br>Province: ${attrs.PROVINCE}`;
                            }
                            if (attrs.POPULATION) {
                                tooltip.innerHTML += `<br>Population: ${attrs.POPULATION.toLocaleString()}`;
                            }
                        }
                        tooltip.style.display = 'block';
                        tooltip.style.left = `${event.x + 10}px`;
                        tooltip.style.top = `${event.y + 10}px`;
                    } else {
                        tooltip.style.display = 'none';
                    }
                });
            });
            
            view.on("pointer-leave", function() {
                tooltip.style.display = 'none';
            });

            // Download as GeoJSON
            downloadBtn.addEventListener('click', async function() {
                if (selectedFeatures.length === 0) return;
                
                try {
                    status.textContent = 'Preparing download...';
                    
                    // Process each selected feature
                    const features = await Promise.all(selectedFeatures.map(async feature => {
                        // Convert coordinates with proper projection
                        const coordinates = await convertEsriGeometryToGeoJSON(feature.geometry);
                        
                        return {
                            type: "Feature",
                            geometry: {
                                type: "Polygon",
                                coordinates: coordinates
                            },
                            properties: {
                                ...feature.attributes,
                                // Add metadata about projection
                                export_metadata: {
                                    exported_date: new Date().toISOString(),
                                    original_crs: feature.geometry.spatialReference ? 
                                        `EPSG:${feature.geometry.spatialReference.wkid}` : 'Unknown',
                                    target_crs: 'EPSG:4326',
                                    target_crs_name: 'WGS 84'
                                }
                            }
                        };
                    }));
                    
                    // Create GeoJSON object
                    const geoJSON = {
                        type: "FeatureCollection",
                        crs: {
                            type: "name",
                            properties: {
                                name: "urn:ogc:def:crs:EPSG::4326"
                            }
                        },
                        metadata: {
                            exported_by: "RapidSOS PSAP Map",
                            export_date: new Date().toISOString(),
                            feature_count: features.length
                        },
                        features: features
                    };
                    
                    // Create and download the file
                    const dataStr = JSON.stringify(geoJSON, null, 2);
                    const dataBlob = new Blob([dataStr], {type: 'application/json'});
                    const url = URL.createObjectURL(dataBlob);
                    
                    // Create download link
                    const downloadLink = document.createElement('a');
                    downloadLink.href = url;
                    
                    // Create filename with timestamp
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    const filename = `psap_boundaries_${selectedFeatures.length}_polygons_WGS84_${timestamp}.geojson`;
                    
                    downloadLink.download = filename;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    URL.revokeObjectURL(url);
                    
                    if (activeLayer === 'psap') {
                        status.textContent = `Downloaded ${selectedFeatures.length} PSAP boundary polygons in WGS84 format`;
                    } else if (activeLayer === 'canada') {
                        status.textContent = `Downloaded ${selectedFeatures.length} Canada Towns polygons in WGS84 format`;
                    } else {
                        status.textContent = `Downloaded ${selectedFeatures.length} features in WGS84 format`;
                    }
                } catch (error) {
                    console.error('Error downloading GeoJSON:', error);
                    status.textContent = 'Error preparing download';
                }
            });

            // Helper function to convert ESRI geometry to GeoJSON with projection
            async function convertEsriGeometryToGeoJSON(geometry) {
                try {
                    // Create target spatial reference (WGS84 / EPSG:4326)
                    const wgs84 = new SpatialReference({ wkid: 4326 });

                    let projectedGeometry = geometry;

                    // Check if geometry needs projection
                    if (geometry.spatialReference && geometry.spatialReference.wkid !== 4326) {
                        console.log(`Projecting from EPSG:${geometry.spatialReference.wkid} to EPSG:4326`);

                        // Load projection engine if not already loaded
                        await projection.load();

                        // Project geometry to WGS84
                        projectedGeometry = projection.project(geometry, wgs84);
                    }

                    // Convert to GeoJSON coordinate format
                    if (projectedGeometry.rings) {
                        // Polygon geometry
                        return projectedGeometry.rings.map(ring =>
                            ring.map(coord => [coord[0], coord[1]])
                        );
                    }

                    return [];
                } catch (error) {
                    console.error('Error converting geometry coordinates:', error);
                    console.log('Falling back to original coordinates');

                    // Fallback to original method if projection fails
                    if (geometry.rings) {
                        return geometry.rings.map(ring =>
                            ring.map(coord => [coord[0], coord[1]])
                        );
                    }
                    return [];
                }
            }

            // Set up the sketch widget for polygon drawing
            function setupDrawTools() {
                // Create the sketch widget for drawing polygons
                sketch = new Sketch({
                    layer: drawLayer,
                    view: view,
                    creationMode: "update",
                    availableCreateTools: ["polygon"], // Only allow polygon creation
                    defaultCreateOptions: {
                        mode: "click" // Default to click-by-click polygon creation
                    },
                    visibleElements: {
                        createTools: {
                            point: false,
                            polyline: false,
                            polygon: true,
                            rectangle: false,
                            circle: false
                        },
                        selectionTools: {
                            "lasso-selection": false,
                            "rectangle-selection": false
                        },
                        undoRedoMenu: true,
                        settingsMenu: false
                    }
                });
                
                // Track drawing state
                sketch.on(["create", "update", "delete"], function(event) {
                    if (event.state === "complete") {
                        // Show download button when drawing is complete
                        if (drawLayer.graphics.length > 0) {
                            downloadDrawnBtn.style.display = "block";
                            status.textContent = "Polygon drawn! You can now download it or continue editing.";
                        } else {
                            downloadDrawnBtn.style.display = "none";
                        }
                    }
                });
                
                return sketch;
            }
            
            // Toggle drawing mode
            function toggleDrawingMode() {
                drawingMode = !drawingMode;
                
                if (drawingMode) {
                    // Activate drawing mode
                    if (!sketch) {
                        sketch = setupDrawTools();
                    }
                    view.ui.add(sketch, { position: "bottom-right" });
                    
                    // Add highlight class to the drawing tools
                    const sketchContainer = document.querySelector('.esri-sketch');
                    if (sketchContainer) {
                        sketchContainer.classList.add('drawing-tools-highlight');
                        // Remove highlight after animation completes
                        setTimeout(() => {
                            sketchContainer.classList.remove('drawing-tools-highlight');
                        }, 3000);
                    }
                    
                    drawPolygonBtn.textContent = "‚úèÔ∏è Exit Drawing Mode";
                    drawPolygonBtn.classList.add("active");
                    status.textContent = "Drawing mode active. Click to create polygon vertices, double-click to complete.";
                } else {
                    // Deactivate drawing mode
                    if (sketch) {
                        view.ui.remove(sketch);
                    }
                    drawPolygonBtn.textContent = "‚úèÔ∏è Draw Polygon";
                    drawPolygonBtn.classList.remove("active");
                    status.textContent = "Drawing mode exited.";
                }
            }
            
            // Get a reference to the layer view for highlighting
            view.whenLayerView(psapLayer).then(function(layerView) {
                psapLayerView = layerView;
                console.log("Layer view created for highlighting");
            });

            // Function to download drawn polygons as GeoJSON
            async function downloadDrawnPolygons() {
                // Get all graphics from the draw layer
                const graphics = drawLayer.graphics.toArray();
                
                if (graphics.length === 0) {
                    alert("No polygons drawn! Draw a polygon first.");
                    return;
                }
                
                try {
                    status.textContent = 'Preparing download of drawn polygon...';
                    
                    // Process each drawn graphic
                    const features = await Promise.all(graphics.map(async function(graphic, index) {
                        // Convert coordinates with proper projection
                        const coordinates = await convertEsriGeometryToGeoJSON(graphic.geometry);
                        
                        return {
                            type: "Feature",
                            geometry: {
                                type: "Polygon",
                                coordinates: coordinates
                            },
                            properties: {
                                id: index + 1,
                                name: `User Drawn Polygon ${index + 1}`,
                                drawn_date: new Date().toISOString(),
                                export_metadata: {
                                    exported_date: new Date().toISOString(),
                                    source: "User Drawing",
                                    target_crs: "EPSG:4326",
                                    target_crs_name: "WGS 84"
                                }
                            }
                        };
                    }));
                    
                    // Create GeoJSON object
                    const geoJSON = {
                        type: "FeatureCollection",
                        crs: {
                            type: "name",
                            properties: {
                                name: "urn:ogc:def:crs:EPSG::4326"
                            }
                        },
                        metadata: {
                            exported_by: "RapidSOS PSAP Map - Drawing Tool",
                            export_date: new Date().toISOString(),
                            feature_count: features.length
                        },
                        features: features
                    };
                    
                    // Create and download the file
                    const dataStr = JSON.stringify(geoJSON, null, 2);
                    const dataBlob = new Blob([dataStr], {type: 'application/json'});
                    const url = URL.createObjectURL(dataBlob);
                    
                    // Create download link
                    const downloadLink = document.createElement('a');
                    downloadLink.href = url;
                    
                    // Create filename with timestamp
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    const filename = `user_drawn_polygons_${timestamp}.geojson`;
                    
                    downloadLink.download = filename;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    URL.revokeObjectURL(url);
                    status.textContent = `Downloaded ${drawnPolygons.length} drawn polygon(s) as GeoJSON`;
                } catch (error) {
                    console.error('Error downloading drawn polygons:', error);
                    alert('Error downloading drawn polygons. Please try again.');
                    status.textContent = 'Error during download';
                }
            }
            
            // Multi-select is now the default behavior, so no toggle function needed
            
            function downloadSelected() {
                if (selectedFeatures.length === 0) return;
                
                try {
                    status.textContent = 'Preparing download...';
                    
                    // Process each selected feature
                    Promise.all(selectedFeatures.map(async feature => {
                        // Convert coordinates with proper projection
                        const coordinates = await convertEsriGeometryToGeoJSON(feature.geometry);
                        
                        return {
                            type: "Feature",
                            geometry: {
                                type: "Polygon",
                                coordinates: coordinates
                            },
                            properties: {
                                ...feature.attributes,
                                // Add metadata about projection
                                export_metadata: {
                                    exported_date: new Date().toISOString(),
                                    original_crs: feature.geometry.spatialReference ? 
                                        `EPSG:${feature.geometry.spatialReference.wkid}` : 'Unknown',
                                    target_crs: 'EPSG:4326',
                                    target_crs_name: 'WGS 84'
                                }
                            }
                        };
                    })).then(features => {
                        // Create GeoJSON object
                        const geoJSON = {
                            type: "FeatureCollection",
                            crs: {
                                type: "name",
                                properties: {
                                    name: "urn:ogc:def:crs:EPSG::4326"
                                }
                            },
                            metadata: {
                                exported_by: "RapidSOS PSAP Map",
                                export_date: new Date().toISOString(),
                                feature_count: features.length
                            },
                            features: features
                        };
                        
                        // Convert to JSON string and download
                        const json = JSON.stringify(geoJSON, null, 2);
                        const blob = new Blob([json], {type: "application/json"});
                        const url = URL.createObjectURL(blob);
                        
                        const downloadLink = document.createElement('a');
                        downloadLink.href = url;
                        downloadLink.download = `${activeLayer === 'psap' ? 'psap' : 'canada_towns'}_export_${new Date().toISOString().slice(0,10)}.geojson`;
                        document.body.appendChild(downloadLink);
                        downloadLink.click();
                        document.body.removeChild(downloadLink);
                        URL.revokeObjectURL(url);
                        
                        if (activeLayer === 'psap') {
                            status.textContent = `Downloaded ${selectedFeatures.length} PSAP boundary polygons in WGS84 format`;
                        } else {
                            status.textContent = `Downloaded ${selectedFeatures.length} Canadian Towns in WGS84 format`;
                        }
                    }).catch(error => {
                        console.error('Error downloading GeoJSON:', error);
                        alert('Error preparing download. Please try again.');
                        status.textContent = 'Error during download';
                    });
                    
                } catch (error) {
                    console.error('Error downloading GeoJSON:', error);
                    alert('Error downloading GeoJSON. Please try again.');
                    status.textContent = 'Error during download';
                }
            }
            
            // Attach event handlers to buttons
            // Make sure clearAllBtn event listener is properly attached
            clearAllBtn.addEventListener('click', clearAllSelections);
            downloadBtn.addEventListener('click', downloadSelected);
            drawPolygonBtn.addEventListener('click', toggleDrawingMode);
            downloadDrawnBtn.addEventListener('click', downloadDrawnPolygons);
            
            // Multi-select button functionality
            multiSelectBtn.addEventListener('click', function() {
                multiSelectMode = !multiSelectMode;
                multiSelectBtn.textContent = multiSelectMode ? 'üîò Multi-Select: ON' : 'üîò Multi-Select: OFF';
                status.textContent = multiSelectMode ? 'Multi-select mode activated. Click on multiple features to select them.' : 'Multi-select mode deactivated. Click on a feature to select it.';
            });
            
            // Koordinates load button functionality
            const loadKoordinatesBtn = document.getElementById('loadKoordinatesBtn');
            if (loadKoordinatesBtn) {
                loadKoordinatesBtn.addEventListener('click', function() {
                    status.textContent = 'Loading Koordinates data...';
                    loadKoordinatesDataInView();
                });
            }
            
            // Function to switch between PSAP and Canadian Towns layers
            // Now just changes visual focus but both layers remain selectable
            function switchActiveLayer() {
                // This function is now a wrapper for toggleActiveLayer for backward compatibility
                toggleActiveLayer();
            }
            
            // Area selection functionality
            function handleAreaSelection() {
                // Check if user has made a selection before (stored in localStorage)
                if (localStorage.getItem('psapMapAreaSelected') === 'true') {
                    console.log('Area already selected previously, not showing modal');
                    return; // Skip showing the modal entirely
                }
                
                // Show the modal only ONCE
                console.log('Showing area selection modal');
                areaSelectionModal.style.display = 'block';
                
                // Set up the area selection function to permanently mark selection as made
                selectUSBtn.addEventListener('click', function() {
                    // Mark selection as made
                    localStorage.setItem('psapMapAreaSelected', 'true');
                    selectArea('us');
                });
                
                selectCanadaBtn.addEventListener('click', function() {
                    // Mark selection as made
                    localStorage.setItem('psapMapAreaSelected', 'true');
                    selectArea('canada');
                });
                
                selectDefaultBtn.addEventListener('click', function() {
                    // Mark selection as made
                    localStorage.setItem('psapMapAreaSelected', 'true');
                    selectArea('default');
                });
            }
            
            // Show tutorial on first visit or when help button is clicked
            const tutorialOverlay = document.getElementById('tutorial-overlay');
            const helpButton = document.getElementById('helpButton');
            const tutorialClose = document.querySelector('.tutorial-close');
            const tutorialGotIt = document.getElementById('tutorialGotIt');
            const dontShowAgain = document.getElementById('dontShowAgain');
            
            // Check if user has seen the tutorial before
            const hasSeenTutorial = localStorage.getItem('hasSeenPSAPMapTutorial');
            
            function showTutorial() {
                tutorialOverlay.style.visibility = 'visible';
                tutorialOverlay.style.opacity = '1';
                document.body.style.overflow = 'hidden'; // Prevent scrolling
            }
            
            function hideTutorial() {
                tutorialOverlay.style.opacity = '0';
                setTimeout(() => {
                    tutorialOverlay.style.visibility = 'hidden';
                    document.body.style.overflow = ''; // Re-enable scrolling
                }, 300);
            }
            
            // Event listeners for tutorial controls
            helpButton.addEventListener('click', showTutorial);
            tutorialClose.addEventListener('click', hideTutorial);
            tutorialGotIt.addEventListener('click', hideTutorial);
            
            dontShowAgain.addEventListener('click', function() {
                localStorage.setItem('hasSeenPSAPMapTutorial', 'true');
                hideTutorial();
            });
            
            // Show tutorial on first visit
            if (!hasSeenTutorial) {
                // Wait for map to load
                setTimeout(() => {
                    showTutorial();
                }, 2000);
            }

            // Call the function ONE time at startup
            window.addEventListener('load', function() {
                // Wait for the map to be fully loaded
                setTimeout(handleAreaSelection, 1500);
            });
            
            // Add click handler for feature selection from both layers
            view.on("click", function(event) {
                // Don't process clicks if drawing mode is active
                if (sketch) {
                    return;
                }
                
                // Get the screen point for hit testing
                const screenPoint = {
                    x: event.x,
                    y: event.y
                };
                
                // Perform hit test to see if user clicked on a feature
                view.hitTest(screenPoint).then(function(response) {
                    // Check all layers for features
                    // First check for PSAP features
                    const psapFeature = response.results.find(result => 
                        result.graphic && result.graphic.layer === psapLayer
                    );
                    
                    // Then check for Canadian Towns features
                    const canadaFeature = response.results.find(result => 
                        result.graphic && result.graphic.layer === canadaTownsLayer
                    );
                    
                    // Check for Koordinates features
                    const koordinatesFeature = response.results.find(result => 
                        result.graphic && result.graphic.layer === koordinatesLayer
                    );
                    
                    // Check for StatCan features
                    const statcanFeature = response.results.find(result => 
                        result.graphic && result.graphic.layer === statcanCSDLayer
                    );
                    
                    // First try the active layer, then fall back to other layers
                    let clickedFeature = null;
                    if (activeLayer === 'psap') {
                        clickedFeature = psapFeature || canadaFeature || statcanFeature || koordinatesFeature;
                    } else if (activeLayer === 'canada') {
                        clickedFeature = canadaFeature || psapFeature || statcanFeature || koordinatesFeature;
                    } else if (activeLayer === 'statcan') {
                        clickedFeature = statcanFeature || psapFeature || canadaFeature || koordinatesFeature;
                    } else if (activeLayer === 'koordinates') {
                        clickedFeature = koordinatesFeature || psapFeature || canadaFeature || statcanFeature;
                    }
                    
                    if (clickedFeature) {
                        const feature = clickedFeature.graphic;
                        console.log('Clicked feature:', feature);
                        
                        // Check for multi-select: either explicit multi-select mode OR modifier keys
                        const isModifierPressed = event.native.ctrlKey || 
                                              event.native.metaKey || 
                                              event.native.shiftKey;
                        
                        const shouldMultiSelect = multiSelectMode || isModifierPressed;
                        console.log('Selection debug:', {
                            multiSelectMode, 
                            isModifierPressed, 
                            shouldMultiSelect, 
                            currentSelectionCount: selectedFeatures.length
                        });
                        
                        // Get feature ID for consistent comparison
                        const featureId = feature.attributes.OBJECTID || feature.attributes.FID;
                        
                        // Check if this feature is already selected
                        const existingIndex = selectedFeatures.findIndex(f => 
                            (f.attributes.OBJECTID === featureId) || (f.attributes.FID === featureId)
                        );
                        
                        if (existingIndex >= 0) {
                            // Feature already selected - remove it (toggle behavior)
                            // Get feature properties for status message
                            const isPsapFeature = feature.layer === psapLayer;
                            const featureName = isPsapFeature ? 
                                getPsapName(feature.attributes) : 
                                getTownName(feature.attributes);
                            
                            // Remove the highlight
                            if (highlightSelections[existingIndex] && highlightSelections[existingIndex].remove) {
                                highlightSelections[existingIndex].remove();
                            }
                            
                            // Remove from arrays
                            selectedFeatures.splice(existingIndex, 1);
                            highlightSelections.splice(existingIndex, 1);
                            
                            // Update UI
                            updateSelectionPanel();
                            status.textContent = `Removed ${featureName} from selection`;
                        } else {
                            // New selection
                            if (!shouldMultiSelect && selectedFeatures.length > 0) {
                                // Single select mode and we have existing selections - clear them first
                                console.log('Clearing previous selections for single select');
                                clearAllSelections();
                            }
                            
                            // Add new selection
                            selectedFeatures.push(feature);
                            console.log('Added feature, total selections:', selectedFeatures.length);
                            
                            // Highlight selected feature based on which layer it belongs to
                            const isPsapFeature = feature.layer === psapLayer;
                            
                            if (isPsapFeature && psapLayerView) {
                                const highlight = psapLayerView.highlight(feature);
                                highlightSelections.push(highlight);
                                const psapName = getPsapName(feature.attributes);
                                status.textContent = `Added ${psapName} to selection (${selectedFeatures.length} total)`;
                            } else if (!isPsapFeature && canadaTownsLayerView) {
                                const highlight = canadaTownsLayerView.highlight(feature);
                                highlightSelections.push(highlight);
                                const townName = getTownName(feature.attributes);
                                status.textContent = `Added ${townName} to selection (${selectedFeatures.length} total)`;
                            }
                            
                            // Update selection panel
                            updateSelectionPanel();
                        }
                    } else {
                        // Clicked on empty area
                        if (!multiSelectMode && !event.native.ctrlKey && !event.native.metaKey && selectedFeatures.length > 0) {
                            // In single-select mode, clear selections when clicking on empty space
                            // (this matches the behavior in the Canada app)
                            clearAllSelections();
                        }
                    }
                });
            });
            
            // Set initial visibility - both layers visible
            psapLayer.visible = true;
            canadaTownsLayer.visible = true;
            
            // Create layer views for both layers
            view.whenLayerView(psapLayer).then(function(layerView) {
                psapLayerView = layerView;
                console.log("Layer view created for highlighting");
                
                // Highlight any selected features
                highlightSelectedFeatures();
            });
            
            view.whenLayerView(canadaTownsLayer).then(function(layerView) {
                canadaTownsLayerView = layerView;
                console.log("Canada Towns layer view created");
            });
            
            view.whenLayerView(statcanCSDLayer).then(function(layerView) {
                statcanCSDLayerView = layerView;
                console.log("StatCan CSD layer view created");
            });
            
            // Area selection modal functionality
            const areaSelectionModal = document.getElementById('areaSelectionModal');
            const selectUSBtn = document.getElementById('selectUSBtn');
            const selectCanadaBtn = document.getElementById('selectCanadaBtn');
            const selectDefaultBtn = document.getElementById('selectDefaultBtn');
            
            // Function to handle area selection
            function selectArea(area) {
                console.log(`Selected area: ${area}`);
                
                // Close the modal
                areaSelectionModal.style.display = 'none';
                
                // Set the appropriate layer as active based on selection
                if (area === 'canada') {
                    activeLayer = 'canada';
                    psapLayer.opacity = 0.3;
                    canadaTownsLayer.opacity = 1.0;
                    layerSwitchBtn.textContent = 'Focus: Canadian Provinces';
                    
                    // Zoom to Canada
                    view.goTo({
                        target: {
                            xmin: -141.0,
                            ymin: 41.0,
                            xmax: -52.0,
                            ymax: 83.0,
                            spatialReference: { wkid: 4326 }
                        },
                        padding: { left: 20, right: 20, top: 20, bottom: 20 }
                    });
                    
                    // Update placeholder text for search input
                    searchInput.placeholder = 'Search for a province...';
                    
                } else {
                    // Default to US/other
                    activeLayer = 'psap';
                    canadaTownsLayer.opacity = 0.3;
                    psapLayer.opacity = 1.0;
                    layerSwitchBtn.textContent = 'Focus: US PSAPs';
                    
                    // Zoom to US
                    view.goTo({
                        target: {
                            xmin: -125.0,
                            ymin: 24.0,
                            xmax: -66.0,
                            ymax: 49.0,
                            spatialReference: { wkid: 4326 }
                        },
                        padding: { left: 20, right: 20, top: 20, bottom: 20 }
                    });
                    
                    // Update placeholder text for search input
                    searchInput.placeholder = 'Search for a PSAP...';
                }
            }
            
            // Event listeners for area selection buttons
            selectUSBtn.addEventListener('click', function() {
                selectArea('us');
            });
            
            selectCanadaBtn.addEventListener('click', function() {
                selectArea('canada');
            });
            
            selectDefaultBtn.addEventListener('click', function() {
                selectArea('other');
            });
            
            // Initialize the map with graphics layers
            console.log("Graphics layers created successfully");
            status.textContent = "Loading PSAP 911 service areas and province data...";

            // Zoom to a good default view
            view.goTo({
                target: {
                    xmin: -125.0,
                    ymin: 24.0,
                    xmax: -66.0,
                    ymax: 60.0,
                    spatialReference: { wkid: 4326 }
                },
                padding: { left: 20, right: 20, top: 20, bottom: 20 }
            });

            // Initialize UI
            updateStatus();
        });
    </script>
</body>
</html>
